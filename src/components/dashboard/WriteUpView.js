import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useFilter } from '../../contexts/FilterContext';
import { useExcelData } from '../../contexts/ExcelDataContext';
import { computeCellValue as sharedComputeCellValue } from '../../utils/computeCellValue';
import './WriteUpView.css';

// Enhanced utility functions
const debounce = (func, wait) => {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};

// Format MT (Metric Tons) with thousand separators
const formatMT = (volumeInKg) => {
  if (typeof volumeInKg !== 'number' || isNaN(volumeInKg)) return '0';
  const mt = Math.round(volumeInKg / 1000);
  return mt.toLocaleString();
};

const createHistoryStack = (initialState = null, maxSize = 50) => {
  let stack = initialState ? [initialState] : [];
  let currentIndex = initialState ? 0 : -1;
  
  return {
    push(state) {
      if (currentIndex < stack.length - 1) {
        stack = stack.slice(0, currentIndex + 1);
      }
      stack.push(state);
      if (stack.length > maxSize) {
        stack = stack.slice(stack.length - maxSize);
      }
      currentIndex = stack.length - 1;
    },
    undo() {
      if (currentIndex > 0) {
        currentIndex--;
        return stack[currentIndex];
      }
      return null;
    },
    redo() {
      if (currentIndex < stack.length - 1) {
        currentIndex++;
        return stack[currentIndex];
      }
      return null;
    },
    canUndo() {
      return currentIndex > 0;
    },
    canRedo() {
      return currentIndex < stack.length - 1;
    },
    current() {
      return currentIndex >= 0 ? stack[currentIndex] : null;
    }
  };
};

// Export functionality
const exportWriteup = async (content, format) => {
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `Financial_Analysis_${timestamp}`;

  switch (format) {
    case 'pdf':
      // Create a new window with the content for PDF printing
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <html>
          <head>
            <title>${filename}</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
              h3 { color: #1f2937; border-bottom: 1px solid #e5e7eb; padding-bottom: 4px; }
              strong { font-weight: 600; }
            </style>
          </head>
          <body>
            ${content.replace(/\n/g, '<br>').replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')}
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();
      break;
    
    case 'txt':
      const blob = new Blob([content], { type: 'text/plain' });
      downloadBlob(blob, `${filename}.txt`);
      break;
    
    case 'markdown':
      downloadBlob(new Blob([content], { type: 'text/markdown' }), `${filename}.md`);
      break;
    
    default:
      console.error('Unsupported export format');
  }
};

const downloadBlob = (blob, filename) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// Enhanced WriteUp component
const WriteUpView = ({ tableData, selectedPeriods }) => {
  const { excelData, selectedDivision } = useExcelData();
  const { basePeriodIndex, columnOrder } = useFilter();
  
  // Main state
  const [writeup, setWriteup] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [regenerationFeedback, setRegenerationFeedback] = useState('');
  
  // Chat state
  const [chatMessages, setChatMessages] = useState([]);
  const [currentPrompt, setCurrentPrompt] = useState('');
  const [selectedText, setSelectedText] = useState('');
  const [showChat, setShowChat] = useState(false);
  const [chatLoading, setChatLoading] = useState(false);
  
  // Preferences state
  const [userPreferences, setUserPreferences] = useState({});
  const [showPreferences, setShowPreferences] = useState(false);
  
  // Export state
  const [showExportOptions, setShowExportOptions] = useState(false);
  const [exportFormat, setExportFormat] = useState('pdf');
  const [isExporting, setIsExporting] = useState(false);
  
  // History state for undo/redo
  const [historyStack] = useState(() => createHistoryStack());
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  
  // Refs
  const writeupRef = useRef(null);
  const chatInputRef = useRef(null);
  const messagesEndRef = useRef(null);
  
  // Division names
  const divisionNames = useMemo(() => ({
    FP: 'Flexible Packaging Division',
    SB: 'Shopping Bags Division', 
    TF: 'Thermoforming Products Division',
    HCM: 'Preforms and Closures Division',
  }), []);
  
  const periods = columnOrder;
  const basePeriod = periods[basePeriodIndex];
  const periodKey = selectedPeriods.map(p => `${p.year}-${p.month || 'Year'}-${p.type}`).join('|');
  
  // Helper functions
  const divisionData = excelData[selectedDivision] || [];
  const computeCellValue = (rowIndex, column) =>
    sharedComputeCellValue(divisionData, rowIndex, column);

  // Load preferences
  useEffect(() => {
    const savedPreferences = localStorage.getItem(`aiWriteupPreferences_${selectedDivision}`);
    if (savedPreferences) {
      try {
        setUserPreferences(JSON.parse(savedPreferences));
      } catch (err) {
        console.warn('Failed to load preferences:', err);
      }
    }
  }, [selectedDivision]);

  // Save preferences
  useEffect(() => {
    if (Object.keys(userPreferences).length > 0) {
      localStorage.setItem(`aiWriteupPreferences_${selectedDivision}`, JSON.stringify(userPreferences));
    }
  }, [userPreferences, selectedDivision]);

  // Reset on period/division change
  useEffect(() => {
    setWriteup('');
    setHasAutoGenerated(false);
    setError(null);
    setChatMessages([]);
    setRegenerationFeedback('');
  }, [periodKey, selectedDivision]);

  // Update history stack state
  const updateHistoryState = useCallback(() => {
    setCanUndo(historyStack.canUndo());
    setCanRedo(historyStack.canRedo());
  }, [historyStack]);

  // Undo/Redo functions
  const undo = useCallback(() => {
    const previousState = historyStack.undo();
    if (previousState) {
      setWriteup(previousState);
      if (writeupRef.current) {
        writeupRef.current.innerHTML = formatWriteupForDisplay(previousState);
      }
      updateHistoryState();
    }
  }, [historyStack, updateHistoryState]);

  const redo = useCallback(() => {
    const nextState = historyStack.redo();
    if (nextState) {
      setWriteup(nextState);
      if (writeupRef.current) {
        writeupRef.current.innerHTML = formatWriteupForDisplay(nextState);
      }
      updateHistoryState();
    }
  }, [historyStack, updateHistoryState]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable) {
        return;
      }
      
      if (event.ctrlKey && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        if (canUndo) undo();
      } else if ((event.ctrlKey && event.key === 'y') || (event.ctrlKey && event.shiftKey && event.key === 'Z')) {
        event.preventDefault();
        if (canRedo) redo();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, canUndo, canRedo]);

  // Format writeup for display
  const formatWriteupForDisplay = (text) => {
    if (!text) return '';
    
    return text
      .replace(/\*\*([A-Z\s:]+)\*\*/g, '<h3 style="font-size: 18px; font-weight: 700; color: #1f2937; margin: 16px 0 8px 0; border-bottom: 1px solid #e5e7eb; padding-bottom: 4px;">$1</h3>')
      .replace(/\*\*([^*]+)\*\*/g, '<strong style="font-weight: 600; color: #374151;">$1</strong>')
      .replace(/\n• /g, '<br/>• ')
      .replace(/\n\n/g, '<br/><br/>')
      .replace(/\n/g, '<br/>');
  };

  // Apply user preferences
  const applyUserPreferences = useCallback((content) => {
    let modifiedContent = content;
    
    if (userPreferences.excludeMarketPositioning) {
      modifiedContent = modifiedContent.replace(/• Market Positioning:.*?\n/g, '');
      modifiedContent = modifiedContent.replace(/\*\*Market Position.*?\n\n/gs, '');
    }
    
    if (userPreferences.excludeIndustryBenchmarks) {
      modifiedContent = modifiedContent.replace(/• Industry comparison:.*?\n/g, '');
      modifiedContent = modifiedContent.replace(/vs Industry norm.*?\n/g, '\n');
    }
    
    if (userPreferences.excludeStrategy) {
      modifiedContent = modifiedContent.replace(/\*\*STRATEGIC RECOMMENDATIONS\*\*.*?(?=\*\*|$)/gs, '');
    }
    
    if (userPreferences.excludeTrends) {
      modifiedContent = modifiedContent.replace(/\(\s*[\+\-]?\d+\.\d+%\s*YoY\)/g, '');
      modifiedContent = modifiedContent.replace(/,\s*[\+\-]?\d+\.\d+%\s*YoY/g, '');
    }
    
    if (userPreferences.preferMT) {
      modifiedContent = modifiedContent.replace(/k tons?/g, 'MT');
    }
    
    return modifiedContent;
  }, [userPreferences]);

  // Generate detailed writeup
  const generateDetailedWriteup = useCallback(async () => {
    if (loading) return;

    setLoading(true);
    setError(null);
    setRegenerationFeedback('');

    try {
      // Validation: Check if base period is selected first
      if (basePeriodIndex === null || !basePeriod) {
        throw new Error('Please Select Base Period');
      }
      
      if (!periods || periods.length === 0) {
        throw new Error('Missing required period data');
      }

      function getKPI(rowIndex, period) {
        if (!period || !computeCellValue) return 0;
        try {
          const value = computeCellValue(rowIndex, period);
          return typeof value === 'number' && !isNaN(value) ? value : 0;
        } catch (err) {
          return 0;
        }
      }

      function getEBIT(period) {
        const netProfit = getKPI(54, period);  // Net Profit row
        const bankInterest = getKPI(42, period);  // Bank Interest row
        return netProfit + bankInterest;
      }

      function formatCurrency(amount) {
        if (typeof amount !== 'number' || isNaN(amount)) return '0.00M';
        return `${(amount / 1000000).toFixed(2)}M`;
      }

      function getCleanPeriodName(period) {
        if (!period) return 'Unknown';
        
        console.log('DEBUG Period:', period); // Debug line
        
        // Handle custom ranges with better formatting
        if (period.isCustomRange && period.displayName) {
          // Convert displayNames like "January_February_March_April" to "Q1"
          const name = period.displayName;
          if (name.includes('January_February_March_April') || name.includes('Jan_Feb_Mar_Apr')) {
            return `${period.year} Q1 ${period.type}`;
          } else if (name.includes('May_June_July_August') || name.includes('May_Jun_Jul_Aug')) {
            return `${period.year} Q2 ${period.type}`;
          } else if (name.includes('September_October_November_December') || name.includes('Sep_Oct_Nov_Dec')) {
            return `${period.year} Q3 ${period.type}`;
          } else if (name.includes('January_February_March') || name.includes('Jan_Feb_Mar')) {
            return `${period.year} Q1 ${period.type}`;
          } else if (name.includes('April_May_June') || name.includes('Apr_May_Jun')) {
            return `${period.year} Q2 ${period.type}`;
          } else if (name.includes('July_August_September') || name.includes('Jul_Aug_Sep')) {
            return `${period.year} Q3 ${period.type}`;
          } else if (name.includes('October_November_December') || name.includes('Oct_Nov_Dec')) {
            return `${period.year} Q4 ${period.type}`;
          } else {
            // For other custom ranges, use a cleaner format
            const cleanName = name.replace(/_/g, '-').replace(/January|February|March|April|May|June|July|August|September|October|November|December/g, (match) => {
              const monthMap = {
                'January': 'Jan', 'February': 'Feb', 'March': 'Mar', 'April': 'Apr',
                'May': 'May', 'June': 'Jun', 'July': 'Jul', 'August': 'Aug',
                'September': 'Sep', 'October': 'Oct', 'November': 'Nov', 'December': 'Dec'
              };
              return monthMap[match] || match;
            });
            return `${period.year} ${cleanName} ${period.type}`;
          }
        }
        
        // Handle regular monthly periods
        if (period.month) {
          return `${period.year} ${period.month} ${period.type}`;
        }
        
        // Handle yearly periods
        return `${period.year} ${period.type}`;
      }

      function getComparisonLabel(basePeriod, comparisonPeriod) {
        const baseName = getCleanPeriodName(basePeriod);
        const compName = getCleanPeriodName(comparisonPeriod);
        
        // Simple approach: just use clean names
        return `${compName} vs ${baseName}`;
      }

      const basePeriodName = getCleanPeriodName(basePeriod);
      const baseData = {
        sales: getKPI(3, basePeriod),
        material: getKPI(5, basePeriod),
        grossProfit: getKPI(4, basePeriod),
        mfgExpenses: getKPI(14, basePeriod),
        belowGP: getKPI(52, basePeriod),
        netProfit: getKPI(54, basePeriod),
        ebitda: getKPI(56, basePeriod),
        salesVolume: getKPI(7, basePeriod),
        labor: getKPI(15, basePeriod),
        electricity: getKPI(17, basePeriod),
        admin: getKPI(19, basePeriod),
      };

      // Get comparison periods data - USE columnOrder directly, not selectedPeriods
      const comparisonPeriods = periods.filter(p => p !== basePeriod);
      
      const totalCosts = baseData.material + baseData.mfgExpenses + baseData.belowGP;
      const ebit = getEBIT(basePeriod);
      const ebitMargin = baseData.sales > 0 ? (ebit / baseData.sales) * 100 : 0;
      
      const metrics = {
        grossMargin: baseData.sales > 0 ? (baseData.grossProfit / baseData.sales) * 100 : 0,
        netMargin: baseData.sales > 0 ? (baseData.netProfit / baseData.sales) * 100 : 0,
        ebitdaMargin: baseData.sales > 0 ? (baseData.ebitda / baseData.sales) * 100 : 0,
        materialRatio: baseData.sales > 0 ? (baseData.material / baseData.sales) * 100 : 0,
        mfgRatio: baseData.sales > 0 ? (baseData.mfgExpenses / baseData.sales) * 100 : 0,
        belowGPRatio: baseData.sales > 0 ? (baseData.belowGP / baseData.sales) * 100 : 0,
        laborRatio: baseData.sales > 0 ? (baseData.labor / baseData.sales) * 100 : 0,
        electricityRatio: baseData.sales > 0 ? (baseData.electricity / baseData.sales) * 100 : 0,
        adminRatio: baseData.sales > 0 ? (baseData.admin / baseData.sales) * 100 : 0,
        pricePerKg: baseData.salesVolume > 0 ? baseData.sales / baseData.salesVolume : 0,
        revenuePerTon: baseData.salesVolume > 0 ? baseData.sales / (baseData.salesVolume / 1000) : 0,
        materialCostPerTon: baseData.salesVolume > 0 ? baseData.material / (baseData.salesVolume / 1000) : 0,
        grossProfitPerTon: baseData.salesVolume > 0 ? baseData.grossProfit / (baseData.salesVolume / 1000) : 0,
        mfgCostPerTon: baseData.salesVolume > 0 ? baseData.mfgExpenses / (baseData.salesVolume / 1000) : 0,
        marginOverMaterial: baseData.material > 0 ? ((baseData.sales - baseData.material) / baseData.material) * 100 : 0,
        totalCosts: totalCosts,
        totalCostRatio: baseData.sales > 0 ? (totalCosts / baseData.sales) * 100 : 0,
      };

      let aiText = `**COMPREHENSIVE FINANCIAL ANALYSIS: ${basePeriodName}**\n`;
      aiText += `**${divisionNames[selectedDivision] || selectedDivision}**\n\n`;

      // Ensure we have comparison periods for analysis
      if (comparisonPeriods.length === 0) {
        aiText += `**NOTE: Only base period selected. Add additional periods for comparative analysis.**\n\n`;
      }
      
      aiText += `**EXECUTIVE SUMMARY**\n`;
      aiText += `• Base Period: ${basePeriodName}\n`;
      aiText += `• Comparison Periods: ${comparisonPeriods.length} period(s) selected\n`;
      aiText += `• Sales: ${formatCurrency(baseData.sales)} (${formatMT(baseData.salesVolume)} MT at ${baseData.salesVolume > 0 ? (baseData.sales / baseData.salesVolume).toFixed(2) : '0.00'} AED/kg)\n`;
      aiText += `• Gross Profit: ${formatCurrency(baseData.grossProfit)} (${metrics.grossMargin.toFixed(1)}% margin)\n`;
      aiText += `• Net Profit: ${formatCurrency(baseData.netProfit)} (${metrics.netMargin.toFixed(1)}% margin)\n`;
      aiText += `• EBIT: ${formatCurrency(ebit)} (${ebitMargin.toFixed(1)}% margin)\n`;
      aiText += `• EBITDA: ${formatCurrency(baseData.ebitda)} (${metrics.ebitdaMargin.toFixed(1)}% margin)\n\n`;
      
      // Sales Analysis with Enhanced Comparisons
      aiText += `**SALES PERFORMANCE ANALYSIS**\n`;
      if (comparisonPeriods.length > 0) {
        comparisonPeriods.forEach(period => {
          const periodName = getCleanPeriodName(period);
          const compSales = getKPI(3, period);
          const compVolume = getKPI(7, period);
          const compPricePerKg = compVolume > 0 ? compSales / compVolume : 0;
          
          const salesChange = compSales > 0 ? ((baseData.sales - compSales) / compSales * 100) : 0;
          const volumeChange = compVolume > 0 ? ((baseData.salesVolume - compVolume) / compVolume * 100) : 0;
          const priceChange = compPricePerKg > 0 ? ((metrics.pricePerKg - compPricePerKg) / compPricePerKg * 100) : 0;
          
          aiText += `• **${getComparisonLabel(basePeriod, period)}:**\n`;
          aiText += `  - Sales Amount: ${formatCurrency(compSales)} → ${formatCurrency(baseData.sales)} (${salesChange >= 0 ? '+' : ''}${salesChange.toFixed(1)}%)\n`;
          aiText += `  - Sales Volume: ${formatMT(compVolume)} MT → ${formatMT(baseData.salesVolume)} MT (${volumeChange >= 0 ? '+' : ''}${volumeChange.toFixed(1)}%)\n`;
          aiText += `  - Price per kg: ${compPricePerKg.toFixed(2)} → ${metrics.pricePerKg.toFixed(2)} AED/kg (${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(1)}%)\n`;
          aiText += `  - **Performance:** ${Math.abs(salesChange) > 15 ? 'MAJOR' : Math.abs(salesChange) > 8 ? 'MODERATE' : 'STABLE'} sales change\n`;
        });
      } else {
        aiText += `• Sales Amount: ${formatCurrency(baseData.sales)} (${formatMT(baseData.salesVolume)} MT)\n`;
        aiText += `• Price per kg: ${baseData.salesVolume > 0 ? (baseData.sales / baseData.salesVolume).toFixed(2) : '0.00'} AED/kg\n`;
        aiText += `• **Note:** Select additional periods for comparative analysis\n`;
      }
      aiText += `\n`;
      
      // Material & Margin Analysis with Enhanced Comparisons
      aiText += `**MATERIAL & MARGIN OVER MATERIAL ANALYSIS**\n`;
      const marginOverMaterial = baseData.material > 0 ? ((baseData.sales - baseData.material) / baseData.material) * 100 : 0;
      const marginOverMaterialAmount = baseData.sales - baseData.material;
      const materialPerKg = baseData.salesVolume > 0 ? baseData.material / baseData.salesVolume : 0;
      
      aiText += `• **Base Period Material Performance:**\n`;
      aiText += `  - Material Cost: ${formatCurrency(baseData.material)} (${metrics.materialRatio.toFixed(1)}% of sales)\n`;
      aiText += `  - Material Cost per kg: ${materialPerKg.toFixed(2)} AED/kg\n`;
      aiText += `  - Margin over Material: ${formatCurrency(marginOverMaterialAmount)} (${marginOverMaterial.toFixed(1)}%)\n`;
      
      if (comparisonPeriods.length > 0) {
        comparisonPeriods.forEach(period => {
          const periodName = getCleanPeriodName(period);
          const compMaterial = getKPI(5, period);
          const compSales = getKPI(3, period);
          const compVolume = getKPI(7, period);
          const compMarginAmount = compSales - compMaterial;
          const compMarginPercent = compMaterial > 0 ? ((compSales - compMaterial) / compMaterial) * 100 : 0;
          const compMaterialRatio = compSales > 0 ? (compMaterial / compSales) * 100 : 0;
          const compMaterialPerKg = compVolume > 0 ? compMaterial / compVolume : 0;
          
          const materialCostChange = compMaterial > 0 ? ((baseData.material - compMaterial) / compMaterial * 100) : 0;
          const materialRatioChange = compMaterialRatio > 0 ? ((metrics.materialRatio - compMaterialRatio) / compMaterialRatio * 100) : 0;
          const marginChange = compMarginAmount > 0 ? ((marginOverMaterialAmount - compMarginAmount) / compMarginAmount * 100) : 0;
          
          aiText += `• **${getComparisonLabel(basePeriod, period)}:**\n`;
          aiText += `  - Material Cost: ${formatCurrency(compMaterial)} → ${formatCurrency(baseData.material)} (${materialCostChange >= 0 ? '+' : ''}${materialCostChange.toFixed(1)}%)\n`;
          aiText += `  - Material % of Sales: ${compMaterialRatio.toFixed(1)}% → ${metrics.materialRatio.toFixed(1)}% (${materialRatioChange >= 0 ? '+' : ''}${materialRatioChange.toFixed(1)}%)\n`;
          aiText += `  - Material AED/kg: ${compMaterialPerKg.toFixed(2)} → ${materialPerKg.toFixed(2)}\n`;
          aiText += `  - Margin over Material: ${formatCurrency(compMarginAmount)} → ${formatCurrency(marginOverMaterialAmount)} (${marginChange >= 0 ? '+' : ''}${marginChange.toFixed(1)}%)\n`;
          aiText += `  - **Impact:** ${Math.abs(materialRatioChange) > 10 ? 'MAJOR' : Math.abs(materialRatioChange) > 5 ? 'MODERATE' : 'MINOR'} material efficiency change\n`;
        });
      }
      aiText += `\n`;
      
      // Manufacturing Costs Analysis
      aiText += `**MANUFACTURING COSTS & DIRECT COSTS ANALYSIS**\n`;
      const mfgCostPerKg = baseData.salesVolume > 0 ? baseData.mfgExpenses / baseData.salesVolume : 0;
      
      aiText += `• **Base Period Manufacturing Performance:**\n`;
      aiText += `  - Total Manufacturing Cost: ${formatCurrency(baseData.mfgExpenses)} (${metrics.mfgRatio.toFixed(1)}% of sales)\n`;
      aiText += `  - Manufacturing Cost per kg: ${mfgCostPerKg.toFixed(2)} AED/kg\n`;
      aiText += `  - Key Cost Components:\n`;
      aiText += `    * Labor: ${formatCurrency(baseData.labor)} (${metrics.laborRatio.toFixed(1)}% of sales)\n`;
      aiText += `    * Electricity: ${formatCurrency(baseData.electricity)} (${metrics.electricityRatio.toFixed(1)}% of sales)\n`;
      
      // Identify highest cost component affecting profitability
      const costComponents = [
        { name: 'Labor', amount: baseData.labor, ratio: metrics.laborRatio },
        { name: 'Electricity', amount: baseData.electricity, ratio: metrics.electricityRatio }
      ];
      const highestCost = costComponents.reduce((max, comp) => comp.amount > max.amount ? comp : max);
      aiText += `  - **HIGHEST IMPACT ON PROFITABILITY:** ${highestCost.name} at ${formatCurrency(highestCost.amount)} (${highestCost.ratio.toFixed(1)}% of sales)\n`;
      
      if (comparisonPeriods.length > 0) {
        comparisonPeriods.forEach(period => {
          const periodName = getCleanPeriodName(period);
          const compMfg = getKPI(14, period);
          const compSales = getKPI(3, period);
          const compVolume = getKPI(7, period);
          const compMfgRatio = compSales > 0 ? (compMfg / compSales) * 100 : 0;
          const compMfgPerKg = compVolume > 0 ? compMfg / compVolume : 0;
          
          const mfgCostChange = compMfg > 0 ? ((baseData.mfgExpenses - compMfg) / compMfg * 100) : 0;
          const mfgRatioChange = compMfgRatio > 0 ? ((metrics.mfgRatio - compMfgRatio) / compMfgRatio * 100) : 0;
          const mfgPerKgChange = compMfgPerKg > 0 ? ((mfgCostPerKg - compMfgPerKg) / compMfgPerKg * 100) : 0;
          
          aiText += `• **${getComparisonLabel(basePeriod, period)}:**\n`;
          aiText += `  - Manufacturing Cost: ${formatCurrency(compMfg)} → ${formatCurrency(baseData.mfgExpenses)} (${mfgCostChange >= 0 ? '+' : ''}${mfgCostChange.toFixed(1)}%)\n`;
          aiText += `  - Manufacturing % of Sales: ${compMfgRatio.toFixed(1)}% → ${metrics.mfgRatio.toFixed(1)}% (${mfgRatioChange >= 0 ? '+' : ''}${mfgRatioChange.toFixed(1)}%)\n`;
          aiText += `  - Manufacturing AED/kg: ${compMfgPerKg.toFixed(2)} → ${mfgCostPerKg.toFixed(2)} (${mfgPerKgChange >= 0 ? '+' : ''}${mfgPerKgChange.toFixed(1)}%)\n`;
          aiText += `  - **Impact:** ${Math.abs(mfgRatioChange) > 15 ? 'CRITICAL' : Math.abs(mfgRatioChange) > 8 ? 'SIGNIFICANT' : 'MODERATE'} manufacturing efficiency change\n`;
        });
      }
      aiText += `\n`;
      
      // Gross Profit Analysis
      aiText += `**GROSS PROFIT ANALYSIS**\n`;
      const grossProfitPerKg = baseData.salesVolume > 0 ? baseData.grossProfit / baseData.salesVolume : 0;
      
      aiText += `• **Base Period Gross Profit Performance:**\n`;
      aiText += `  - Gross Profit: ${formatCurrency(baseData.grossProfit)} (${metrics.grossMargin.toFixed(1)}% of sales)\n`;
      aiText += `  - Gross Profit per kg: ${grossProfitPerKg.toFixed(2)} AED/kg\n`;
      
      if (comparisonPeriods.length > 0) {
        comparisonPeriods.forEach(period => {
          const periodName = getCleanPeriodName(period);
          const compGrossProfit = getKPI(4, period);
          const compSales = getKPI(3, period);
          const compVolume = getKPI(7, period);
          const compGrossMargin = compSales > 0 ? (compGrossProfit / compSales) * 100 : 0;
          const compGrossProfitPerKg = compVolume > 0 ? compGrossProfit / compVolume : 0;
          
          const grossProfitChange = compGrossProfit > 0 ? ((baseData.grossProfit - compGrossProfit) / compGrossProfit * 100) : 0;
          const grossMarginChange = compGrossMargin > 0 ? ((metrics.grossMargin - compGrossMargin) / compGrossMargin * 100) : 0;
          const grossProfitPerKgChange = compGrossProfitPerKg > 0 ? ((grossProfitPerKg - compGrossProfitPerKg) / compGrossProfitPerKg * 100) : 0;
          
          aiText += `• **${getComparisonLabel(basePeriod, period)}:**\n`;
          aiText += `  - Gross Profit: ${formatCurrency(compGrossProfit)} → ${formatCurrency(baseData.grossProfit)} (${grossProfitChange >= 0 ? '+' : ''}${grossProfitChange.toFixed(1)}%)\n`;
          aiText += `  - Gross Margin %: ${compGrossMargin.toFixed(1)}% → ${metrics.grossMargin.toFixed(1)}% (${grossMarginChange >= 0 ? '+' : ''}${grossMarginChange.toFixed(1)}%)\n`;
          aiText += `  - Gross Profit AED/kg: ${compGrossProfitPerKg.toFixed(2)} → ${grossProfitPerKg.toFixed(2)} (${grossProfitPerKgChange >= 0 ? '+' : ''}${grossProfitPerKgChange.toFixed(1)}%)\n`;
          aiText += `  - **Impact:** ${Math.abs(grossMarginChange) > 15 ? 'MAJOR' : Math.abs(grossMarginChange) > 8 ? 'MODERATE' : 'MINOR'} gross profitability change\n`;
        });
      }
      aiText += `\n`;
      
      // Below GP Expenses Analysis
      aiText += `**BELOW GROSS PROFIT EXPENSES ANALYSIS**\n`;
      const belowGPPerKg = baseData.salesVolume > 0 ? baseData.belowGP / baseData.salesVolume : 0;
      
      aiText += `• **Base Period Below GP Expenses:**\n`;
      aiText += `  - Total Below GP Expenses: ${formatCurrency(baseData.belowGP)} (${metrics.belowGPRatio.toFixed(1)}% of sales)\n`;
      aiText += `  - Below GP Expenses per kg: ${belowGPPerKg.toFixed(2)} AED/kg\n`;
      aiText += `  - Key Components:\n`;
      aiText += `    * Admin Expenses: ${formatCurrency(baseData.admin)} (${metrics.adminRatio.toFixed(1)}% of sales)\n`;
      
      // Identify which below GP expense affects profitability most
      aiText += `  - **HIGHEST IMPACT ON PROFITABILITY:** Admin Expenses at ${formatCurrency(baseData.admin)} (${metrics.adminRatio.toFixed(1)}% of sales)\n`;
      
      if (comparisonPeriods.length > 0) {
        comparisonPeriods.forEach(period => {
          const periodName = getCleanPeriodName(period);
          const compBelowGP = getKPI(52, period);
          const compSales = getKPI(3, period);
          const compVolume = getKPI(7, period);
          const compBelowGPRatio = compSales > 0 ? (compBelowGP / compSales) * 100 : 0;
          const compBelowGPPerKg = compVolume > 0 ? compBelowGP / compVolume : 0;
          
          const belowGPChange = compBelowGP > 0 ? ((baseData.belowGP - compBelowGP) / compBelowGP * 100) : 0;
          const belowGPRatioChange = compBelowGPRatio > 0 ? ((metrics.belowGPRatio - compBelowGPRatio) / compBelowGPRatio * 100) : 0;
          const belowGPPerKgChange = compBelowGPPerKg > 0 ? ((belowGPPerKg - compBelowGPPerKg) / compBelowGPPerKg * 100) : 0;
          
          aiText += `• **${getComparisonLabel(basePeriod, period)}:**\n`;
          aiText += `  - Below GP Expenses: ${formatCurrency(compBelowGP)} → ${formatCurrency(baseData.belowGP)} (${belowGPChange >= 0 ? '+' : ''}${belowGPChange.toFixed(1)}%)\n`;
          aiText += `  - Below GP % of Sales: ${compBelowGPRatio.toFixed(1)}% → ${metrics.belowGPRatio.toFixed(1)}% (${belowGPRatioChange >= 0 ? '+' : ''}${belowGPRatioChange.toFixed(1)}%)\n`;
          aiText += `  - Below GP AED/kg: ${compBelowGPPerKg.toFixed(2)} → ${belowGPPerKg.toFixed(2)} (${belowGPPerKgChange >= 0 ? '+' : ''}${belowGPPerKgChange.toFixed(1)}%)\n`;
          aiText += `  - **Impact:** ${Math.abs(belowGPRatioChange) > 20 ? 'HIGH' : Math.abs(belowGPRatioChange) > 10 ? 'MODERATE' : 'LOW'} overhead cost impact\n`;
        });
      }
      aiText += `\n`;
      
      // Total Expenses Analysis
      aiText += `**TOTAL EXPENSES ANALYSIS**\n`;
      const totalExpensesPerKg = baseData.salesVolume > 0 ? metrics.totalCosts / baseData.salesVolume : 0;
      
      aiText += `• **Base Period Total Expenses:**\n`;
      aiText += `  - Total Expenses: ${formatCurrency(metrics.totalCosts)} (${metrics.totalCostRatio.toFixed(1)}% of sales)\n`;
      aiText += `  - Total Expenses per kg: ${totalExpensesPerKg.toFixed(2)} AED/kg\n`;
      aiText += `  - Breakdown: Material ${metrics.materialRatio.toFixed(1)}% + Manufacturing ${metrics.mfgRatio.toFixed(1)}% + Below GP ${metrics.belowGPRatio.toFixed(1)}%\n`;
      
      if (comparisonPeriods.length > 0) {
        comparisonPeriods.forEach(period => {
          const periodName = getCleanPeriodName(period);
          const compMaterial = getKPI(5, period);
          const compMfg = getKPI(14, period);
          const compBelowGP = getKPI(52, period);
          const compTotalCosts = compMaterial + compMfg + compBelowGP;
          const compSales = getKPI(3, period);
          const compVolume = getKPI(7, period);
          const compTotalCostRatio = compSales > 0 ? (compTotalCosts / compSales) * 100 : 0;
          const compTotalExpensesPerKg = compVolume > 0 ? compTotalCosts / compVolume : 0;
          
          const totalExpensesChange = compTotalCosts > 0 ? ((metrics.totalCosts - compTotalCosts) / compTotalCosts * 100) : 0;
          const totalExpensesRatioChange = compTotalCostRatio > 0 ? ((metrics.totalCostRatio - compTotalCostRatio) / compTotalCostRatio * 100) : 0;
          const totalExpensesPerKgChange = compTotalExpensesPerKg > 0 ? ((totalExpensesPerKg - compTotalExpensesPerKg) / compTotalExpensesPerKg * 100) : 0;
          
          aiText += `• **${getComparisonLabel(basePeriod, period)}:**\n`;
          aiText += `  - Total Expenses: ${formatCurrency(compTotalCosts)} → ${formatCurrency(metrics.totalCosts)} (${totalExpensesChange >= 0 ? '+' : ''}${totalExpensesChange.toFixed(1)}%)\n`;
          aiText += `  - Total Expenses % of Sales: ${compTotalCostRatio.toFixed(1)}% → ${metrics.totalCostRatio.toFixed(1)}% (${totalExpensesRatioChange >= 0 ? '+' : ''}${totalExpensesRatioChange.toFixed(1)}%)\n`;
          aiText += `  - Total Expenses AED/kg: ${compTotalExpensesPerKg.toFixed(2)} → ${totalExpensesPerKg.toFixed(2)} (${totalExpensesPerKgChange >= 0 ? '+' : ''}${totalExpensesPerKgChange.toFixed(1)}%)\n`;
          aiText += `  - **Overall Cost Control:** ${Math.abs(totalExpensesRatioChange) > 10 ? 'NEEDS ATTENTION' : Math.abs(totalExpensesRatioChange) > 5 ? 'MONITOR CLOSELY' : 'STABLE'}\n`;
        });
      }
      aiText += `\n`;
      
      // Net Profit/EBIT/EBITDA Analysis
      aiText += `**NET PROFIT/EBIT/EBITDA ANALYSIS**\n`;
      const netProfitPerKg = baseData.salesVolume > 0 ? baseData.netProfit / baseData.salesVolume : 0;
      const ebitPerKg = baseData.salesVolume > 0 ? ebit / baseData.salesVolume : 0;
      const ebitdaPerKg = baseData.salesVolume > 0 ? baseData.ebitda / baseData.salesVolume : 0;
      
      aiText += `• **Base Period Profitability Performance:**\n`;
      aiText += `  - Net Profit: ${formatCurrency(baseData.netProfit)} (${metrics.netMargin.toFixed(1)}% margin)\n`;
      aiText += `  - EBIT: ${formatCurrency(ebit)} (${ebitMargin.toFixed(1)}% margin)\n`;
      aiText += `  - EBITDA: ${formatCurrency(baseData.ebitda)} (${metrics.ebitdaMargin.toFixed(1)}% margin)\n`;
      aiText += `  - Per kg: Net ${netProfitPerKg.toFixed(2)}, EBIT ${ebitPerKg.toFixed(2)}, EBITDA ${ebitdaPerKg.toFixed(2)} AED/kg\n`;
      
      // Business Strength Explanations
      aiText += `\n**BUSINESS STRENGTH INDICATORS:**\n`;
      aiText += `• **EBIT (${ebitMargin.toFixed(1)}% margin):** ${ebitMargin > 15 ? 'STRONG operational profitability before financing costs' : ebitMargin > 10 ? 'ADEQUATE operational performance with room for improvement' : ebitMargin > 5 ? 'WEAK operational efficiency needs immediate attention' : 'CRITICAL operational issues requiring urgent action'}\n`;
      aiText += `• **EBITDA (${metrics.ebitdaMargin.toFixed(1)}% margin):** ${metrics.ebitdaMargin > 20 ? 'EXCELLENT cash generation and debt servicing capacity' : metrics.ebitdaMargin > 15 ? 'GOOD cash flow generation supporting growth investments' : metrics.ebitdaMargin > 10 ? 'MODERATE cash generation limiting expansion potential' : 'POOR cash generation constraining business growth'}\n`;
      aiText += `• **Net Profit (${metrics.netMargin.toFixed(1)}% margin):** ${metrics.netMargin > 10 ? 'STRONG bottom-line performance for shareholders' : metrics.netMargin > 5 ? 'ACCEPTABLE profitability with optimization opportunities' : metrics.netMargin > 2 ? 'THIN margins requiring cost management focus' : 'UNSUSTAINABLE profitability needs immediate intervention'}\n`;
      
      if (comparisonPeriods.length > 0) {
        comparisonPeriods.forEach(period => {
          const periodName = getCleanPeriodName(period);
          const compNetProfit = getKPI(54, period);
          const compEBIT = getEBIT(period);
          const compEBITDA = getKPI(56, period);
          const compSales = getKPI(3, period);
          const compNetMargin = compSales > 0 ? (compNetProfit / compSales) * 100 : 0;
          const compEBITMargin = compSales > 0 ? (compEBIT / compSales) * 100 : 0;
          const compEBITDAMargin = compSales > 0 ? (compEBITDA / compSales) * 100 : 0;
          
          const netProfitChange = compNetProfit > 0 ? ((baseData.netProfit - compNetProfit) / compNetProfit * 100) : 0;
          const ebitChange = compEBIT > 0 ? ((ebit - compEBIT) / compEBIT * 100) : 0;
          const ebitdaChange = compEBITDA > 0 ? ((baseData.ebitda - compEBITDA) / compEBITDA * 100) : 0;
          const netMarginChange = compNetMargin > 0 ? ((metrics.netMargin - compNetMargin) / compNetMargin * 100) : 0;
          const ebitMarginChange = compEBITMargin > 0 ? ((ebitMargin - compEBITMargin) / compEBITMargin * 100) : 0;
          const ebitdaMarginChange = compEBITDAMargin > 0 ? ((metrics.ebitdaMargin - compEBITDAMargin) / compEBITDAMargin * 100) : 0;
          
          aiText += `• **${getComparisonLabel(basePeriod, period)}:**\n`;
          aiText += `  - Net Profit: ${formatCurrency(compNetProfit)} → ${formatCurrency(baseData.netProfit)} (${netProfitChange >= 0 ? '+' : ''}${netProfitChange.toFixed(1)}%)\n`;
          aiText += `  - EBIT: ${formatCurrency(compEBIT)} → ${formatCurrency(ebit)} (${ebitChange >= 0 ? '+' : ''}${ebitChange.toFixed(1)}%)\n`;
          aiText += `  - EBITDA: ${formatCurrency(compEBITDA)} → ${formatCurrency(baseData.ebitda)} (${ebitdaChange >= 0 ? '+' : ''}${ebitdaChange.toFixed(1)}%)\n`;
          aiText += `  - Margin Changes: Net ${netMarginChange >= 0 ? '+' : ''}${netMarginChange.toFixed(1)}%, EBIT ${ebitMarginChange >= 0 ? '+' : ''}${ebitMarginChange.toFixed(1)}%, EBITDA ${ebitdaMarginChange >= 0 ? '+' : ''}${ebitdaMarginChange.toFixed(1)}%\n`;
          aiText += `  - **Performance:** ${Math.abs(netProfitChange) > 20 ? 'DRAMATIC' : Math.abs(netProfitChange) > 10 ? 'SIGNIFICANT' : Math.abs(netProfitChange) > 5 ? 'MODERATE' : 'STABLE'} profitability change\n`;
        });
      }
      
      aiText += `\n**KEY BUSINESS INSIGHTS:**\n`;
      if (comparisonPeriods.length > 0) {
        aiText += `This analysis compares ${basePeriodName} against ${comparisonPeriods.length} selected period(s). `;
      } else {
        aiText += `This analysis covers ${basePeriodName} only. Add comparison periods for trend analysis. `;
      }
      
      // Provide specific management recommendations based on metrics
      if (metrics.netMargin < 5) {
        aiText += `URGENT: Low net margins require immediate cost reduction focus. `;
      }
      if (ebitMargin < 10) {
        aiText += `Operations need efficiency improvements. `;
      }
      if (metrics.ebitdaMargin < 15) {
        aiText += `Cash generation limits growth investment capacity. `;
      }
      
      aiText += `Key management priorities: `;
      const priorities = [];
      if (metrics.materialRatio > 60) priorities.push('material cost optimization');
      if (metrics.mfgRatio > 25) priorities.push('manufacturing efficiency');
      if (metrics.belowGPRatio > 20) priorities.push('overhead cost control');
      if (priorities.length === 0) priorities.push('maintain current performance levels');
      
      aiText += priorities.join(', ') + '.\n';

      const processedText = applyUserPreferences(aiText);
      
      // Add to history before setting new content
      if (writeup) {
        historyStack.push(writeup);
      }
      
      setWriteup(processedText);
      setHasAutoGenerated(true);
      updateHistoryState();

      setChatMessages(prev => [...prev, {
        type: 'system',
        content: `Comprehensive comparative analysis generated with ${Object.keys(userPreferences).length} learned preferences applied.`,
        timestamp: new Date(),
      }]);

    } catch (err) {
      console.error('Error generating writeup:', err);
      setError(`Failed to generate analysis: ${err.message}`);
    } finally {
      setLoading(false);
    }
  }, [basePeriod, selectedPeriods, computeCellValue, selectedDivision, divisionNames, userPreferences, applyUserPreferences, writeup, historyStack, updateHistoryState]);

  // Handle text selection
  const handleTextSelection = () => {
    const selection = window.getSelection();
    const selectedText = selection.toString().trim();
    if (selectedText.length > 0) {
      setSelectedText(selectedText);
      setShowChat(true);
    }
  };

  // Handle writeup edit
  const handleWriteupEdit = debounce((newContent) => {
    if (newContent !== writeup) {
      historyStack.push(writeup);
      setWriteup(newContent);
      updateHistoryState();
    }
  }, 500);

  // Handle export
  const handleExport = async () => {
    setIsExporting(true);
    try {
      await exportWriteup(writeup, exportFormat);
      setShowExportOptions(false);
    } catch (error) {
      console.error('Export failed:', error);
    } finally {
      setIsExporting(false);
    }
  };

  // Scroll chat to bottom
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [chatMessages]);

  return (
    <div className="writeup-view-container">
      <div className="writeup-main-content">
        {/* Header */}
        <div className="writeup-header">
          <div>
            <h2>Financial Analysis Write-up</h2>
            <div className="division-name">
              {divisionNames[selectedDivision] || selectedDivision}
            </div>
          </div>
          <div className="header-controls">
            {/* Undo/Redo buttons */}
            <button 
              onClick={undo}
              disabled={!canUndo}
              title="Undo (Ctrl+Z)"
              className={`control-btn ${canUndo ? 'enabled' : 'disabled'}`}
            >
              ↶ Undo
            </button>
            <button 
              onClick={redo}
              disabled={!canRedo}
              title="Redo (Ctrl+Y)"
              className={`control-btn ${canRedo ? 'enabled' : 'disabled'}`}
            >
              ↷ Redo
            </button>
            
            {/* Export button */}
            <div className="export-dropdown">
              <button
                onClick={() => setShowExportOptions(!showExportOptions)}
                className="control-btn export-btn"
              >
                📤 Export
              </button>
              
              {showExportOptions && (
                <div className="export-options">
                  <h4>Export Format</h4>
                  <label>
                    <input
                      type="radio"
                      name="exportFormat"
                      value="pdf"
                      checked={exportFormat === 'pdf'}
                      onChange={() => setExportFormat('pdf')}
                    />
                    PDF Document
                  </label>
                  <label>
                    <input
                      type="radio"
                      name="exportFormat"
                      value="txt"
                      checked={exportFormat === 'txt'}
                      onChange={() => setExportFormat('txt')}
                    />
                    Plain Text (.txt)
                  </label>
                  <label>
                    <input
                      type="radio"
                      name="exportFormat"
                      value="markdown"
                      checked={exportFormat === 'markdown'}
                      onChange={() => setExportFormat('markdown')}
                    />
                    Markdown (.md)
                  </label>
                  <div className="export-actions">
                    <button onClick={() => setShowExportOptions(false)}>Cancel</button>
                    <button onClick={handleExport} disabled={isExporting}>
                      {isExporting ? 'Exporting...' : 'Export'}
                    </button>
                  </div>
                </div>
              )}
            </div>
            
            <button
              onClick={() => setShowPreferences(!showPreferences)}
              className={`control-btn ${showPreferences ? 'active' : ''}`}
            >
              Preferences ({Object.keys(userPreferences).length})
            </button>
            <button
              onClick={() => setShowChat(!showChat)}
              className={`control-btn ${showChat ? 'active' : ''}`}
            >
              {showChat ? 'Hide Chat' : 'Show Chat'}
            </button>
          </div>
        </div>

        {/* Status messages */}
        {error && <div className="status-message error">{error}</div>}
        {regenerationFeedback && (
          <div className={`status-message ${regenerationFeedback.startsWith('✅') ? 'success' : 'info'}`}>
            {regenerationFeedback}
          </div>
        )}

        {/* Instructions */}
        <div className="instructions-panel">
          <strong>📝 How to Use the AI Writing Assistant:</strong>
          <div>
            <div>1. <strong>Generate Analysis:</strong> Click "Generate Analysis" to create your writeup</div>
            <div>2. <strong>Select Text:</strong> Highlight any part of the analysis to discuss</div>
            <div>3. <strong>Open Chat:</strong> Click "Show Chat" (opens automatically with selection)</div>
            <div>4. <strong>Ask AI:</strong> Expand, correct, remove text, set preferences, or simulate scenarios</div>
            <div className="tip">💡 <strong>Tip:</strong> Selected text appears in a blue box in the chat!</div>
          </div>
        </div>

        {/* Writeup editor */}
        <div className="writeup-content">
          <div
            ref={writeupRef}
            contentEditable
            suppressContentEditableWarning
            onMouseUp={handleTextSelection}
            onInput={(e) => handleWriteupEdit(e.currentTarget.innerText)}
            className="writeup-editor"
            spellCheck={true}
          >
            {writeup ? (
              <div dangerouslySetInnerHTML={{ __html: formatWriteupForDisplay(writeup) }} />
            ) : (
              <div className="placeholder-text">
                Click "Generate Analysis" to create a comprehensive financial analysis. Use the chat to expand, correct, remove text, simulate scenarios, or recall past requests.
              </div>
            )}
          </div>
        </div>

        {/* Action buttons */}
        <div className="action-buttons">
          {selectedText && (
            <button
              onClick={() => {
                if (!selectedText) {
                  alert('Please select some text in the writeup above first.');
                }
              }}
              className="capture-btn"
            >
              📌 Capture Selected Text
            </button>
          )}
          <button
            onClick={generateDetailedWriteup}
            disabled={loading}
            className="generate-btn"
          >
            {loading ? 'Generating...' : 'Generate Analysis'}
          </button>
        </div>
      </div>

      {/* Chat Panel */}
      {showChat && (
        <div className="chat-panel">
          <h3>AI Writing Assistant</h3>
          
          {selectedText && (
            <div className="selected-text-display">
              <div>
                <strong>📌 Selected Text:</strong><br/>
                <span className="selected-text">
                  "{selectedText.length > 150 ? selectedText.substring(0, 150) + '...' : selectedText}"
                </span>
                <div className="selected-text-hint">
                  💬 Expand, correct, remove, simulate scenarios, or recall past requests
                </div>
              </div>
              <button
                onClick={() => setSelectedText('')}
                className="clear-selection-btn"
              >
                Clear
              </button>
            </div>
          )}
          
          {!selectedText && (
            <div className="chat-hint">
              💡 Select text above or type a request below
            </div>
          )}
          
          <div className="chat-messages">
            {chatMessages.map((message, index) => (
              <div
                key={index}
                className={`chat-message ${message.type}`}
              >
                <div className="message-header">
                  {message.type === 'user' ? 'You' : message.type === 'error' ? 'Error' : 'AI Assistant'} - {message.timestamp.toLocaleString()}
                </div>
                <div className="message-content">
                  {message.content}
                </div>
              </div>
            ))}
            {chatLoading && (
              <div className="chat-loading">
                AI is thinking...
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>
          
          <form className="chat-form">
            <textarea
              ref={chatInputRef}
              value={currentPrompt}
              onChange={(e) => setCurrentPrompt(e.target.value)}
              placeholder="Expand (e.g., 'Expand on costs'), correct (e.g., 'Change X to Y'), remove (e.g., 'Remove this text'), set preferences (e.g., 'Focus on margins'), simulate (e.g., 'What if mfg costs by 5%?')..."
              className="chat-input"
              disabled={chatLoading}
            />
            <button
              type="submit"
              disabled={chatLoading || !currentPrompt.trim()}
              className="chat-send-btn"
            >
              {chatLoading ? 'Processing...' : 'Send'}
            </button>
          </form>
          
          <div className="chat-help">
            💡 <strong>Expansion:</strong> "Expand on profitability"<br/>
            🧠 <strong>Preferences:</strong> "Focus on costs", "Use MT"<br/>
            ✏️ <strong>Corrections:</strong> "Change X to Y"<br/>
            🗑️ <strong>Remove:</strong> "Remove this text"<br/>
            📊 <strong>Scenarios:</strong> "What if material costs by 5%?"
          </div>
        </div>
      )}

      {/* Preferences Panel */}
      {showPreferences && (
        <div className="preferences-panel">
          <h3>🧠 Learned Preferences for {divisionNames[selectedDivision] || selectedDivision}</h3>
          
          {Object.keys(userPreferences).length === 0 ? (
            <p className="no-preferences">
              No preferences learned yet. Use the chat to teach preferences (e.g., "Focus on costs", "Remove this text").
            </p>
          ) : (
            <div>
              <div className="preferences-list">
                <strong>Current Preferences:</strong>
                {Object.entries(userPreferences).map(([key, value]) => {
                  if (!value) return null;
                  const getPreferenceDescription = (prefKey) => {
                    const descriptions = {
                      excludeMarketPositioning: '🚫 Exclude market positioning',
                      excludeIndustryBenchmarks: '🚫 Exclude industry benchmarks',
                      excludeStrategy: '🚫 Exclude strategic recommendations',
                      excludeTrends: '🚫 Exclude trend and YoY comparisons',
                      focusOnCosts: '🎯 Focus on cost analysis',
                      focusOnMargins: '🎯 Focus on margin analysis',
                      preferShortFormat: '📝 Prefer short format',
                      preferDetailedFormat: '📝 Prefer detailed format',
                      preferMT: '📏 Use MT units',
                    };
                    return descriptions[prefKey] || prefKey;
                  };
                  return (
                    <div key={key} className="preference-item">
                      <span>{getPreferenceDescription(key)}</span>
                      <button
                        onClick={() => {
                          const newPreferences = { ...userPreferences };
                          delete newPreferences[key];
                          setUserPreferences(newPreferences);
                        }}
                        className="remove-preference-btn"
                      >
                        Remove
                      </button>
                    </div>
                  );
                })}
              </div>
              <div className="preferences-actions">
                <button
                  onClick={() => {
                    setUserPreferences({});
                    localStorage.removeItem(`aiWriteupPreferences_${selectedDivision}`);
                  }}
                  className="clear-all-preferences-btn"
                >
                  Clear All Preferences
                </button>
                <span className="preferences-note">
                  Preferences persist across sessions
                </span>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default WriteUpView; 