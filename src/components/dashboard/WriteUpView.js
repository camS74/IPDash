import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useFilter } from '../../contexts/FilterContext';
import { useExcelData } from '../../contexts/ExcelDataContext';
import { computeCellValue as sharedComputeCellValue } from '../../utils/computeCellValue';
import './WriteUpView.css';

// Enhanced utility functions
const debounce = (func, wait) => {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};

const createHistoryStack = (initialState = null, maxSize = 50) => {
  let stack = initialState ? [initialState] : [];
  let currentIndex = initialState ? 0 : -1;
  
  return {
    push(state) {
      if (currentIndex < stack.length - 1) {
        stack = stack.slice(0, currentIndex + 1);
      }
      stack.push(state);
      if (stack.length > maxSize) {
        stack = stack.slice(stack.length - maxSize);
      }
      currentIndex = stack.length - 1;
    },
    undo() {
      if (currentIndex > 0) {
        currentIndex--;
        return stack[currentIndex];
      }
      return null;
    },
    redo() {
      if (currentIndex < stack.length - 1) {
        currentIndex++;
        return stack[currentIndex];
      }
      return null;
    },
    canUndo() {
      return currentIndex > 0;
    },
    canRedo() {
      return currentIndex < stack.length - 1;
    },
    current() {
      return currentIndex >= 0 ? stack[currentIndex] : null;
    }
  };
};

// Export functionality
const exportWriteup = async (content, format) => {
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `Financial_Analysis_${timestamp}`;

  switch (format) {
    case 'pdf':
      // Create a new window with the content for PDF printing
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <html>
          <head>
            <title>${filename}</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
              h3 { color: #1f2937; border-bottom: 1px solid #e5e7eb; padding-bottom: 4px; }
              strong { font-weight: 600; }
            </style>
          </head>
          <body>
            ${content.replace(/\n/g, '<br>').replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')}
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();
      break;
    
    case 'txt':
      const blob = new Blob([content], { type: 'text/plain' });
      downloadBlob(blob, `${filename}.txt`);
      break;
    
    case 'markdown':
      downloadBlob(new Blob([content], { type: 'text/markdown' }), `${filename}.md`);
      break;
    
    default:
      console.error('Unsupported export format');
  }
};

const downloadBlob = (blob, filename) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// Enhanced WriteUp component
const WriteUpView = ({ tableData, selectedPeriods }) => {
  const { excelData, selectedDivision } = useExcelData();
  const { basePeriodIndex, columnOrder } = useFilter();
  
  // Main state
  const [writeup, setWriteup] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [regenerationFeedback, setRegenerationFeedback] = useState('');
  
  // Chat state
  const [chatMessages, setChatMessages] = useState([]);
  const [currentPrompt, setCurrentPrompt] = useState('');
  const [selectedText, setSelectedText] = useState('');
  const [showChat, setShowChat] = useState(false);
  const [chatLoading, setChatLoading] = useState(false);
  
  // Preferences state
  const [userPreferences, setUserPreferences] = useState({});
  const [showPreferences, setShowPreferences] = useState(false);
  
  // Export state
  const [showExportOptions, setShowExportOptions] = useState(false);
  const [exportFormat, setExportFormat] = useState('pdf');
  const [isExporting, setIsExporting] = useState(false);
  
  // History state for undo/redo
  const [historyStack] = useState(() => createHistoryStack());
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  
  // Refs
  const writeupRef = useRef(null);
  const chatInputRef = useRef(null);
  const messagesEndRef = useRef(null);
  
  // Division names
  const divisionNames = useMemo(() => ({
    FP: 'Flexible Packaging Division',
    SB: 'Shopping Bags Division', 
    TF: 'Thermoforming Products Division',
    HCM: 'Preforms and Closures Division',
  }), []);
  
  const periods = columnOrder;
  const basePeriod = periods[basePeriodIndex];
  const periodKey = selectedPeriods.map(p => `${p.year}-${p.month || 'Year'}-${p.type}`).join('|');
  
  // Helper functions
  const divisionData = excelData[selectedDivision] || [];
  const computeCellValue = (rowIndex, column) =>
    sharedComputeCellValue(divisionData, rowIndex, column);

  // Load preferences
  useEffect(() => {
    const savedPreferences = localStorage.getItem(`aiWriteupPreferences_${selectedDivision}`);
    if (savedPreferences) {
      try {
        setUserPreferences(JSON.parse(savedPreferences));
      } catch (err) {
        console.warn('Failed to load preferences:', err);
      }
    }
  }, [selectedDivision]);

  // Save preferences
  useEffect(() => {
    if (Object.keys(userPreferences).length > 0) {
      localStorage.setItem(`aiWriteupPreferences_${selectedDivision}`, JSON.stringify(userPreferences));
    }
  }, [userPreferences, selectedDivision]);

  // Reset on period/division change
  useEffect(() => {
    setWriteup('');
    setHasAutoGenerated(false);
    setError(null);
    setChatMessages([]);
    setRegenerationFeedback('');
  }, [periodKey, selectedDivision]);

  // Update history stack state
  const updateHistoryState = useCallback(() => {
    setCanUndo(historyStack.canUndo());
    setCanRedo(historyStack.canRedo());
  }, [historyStack]);

  // Undo/Redo functions
  const undo = useCallback(() => {
    const previousState = historyStack.undo();
    if (previousState) {
      setWriteup(previousState);
      if (writeupRef.current) {
        writeupRef.current.innerHTML = formatWriteupForDisplay(previousState);
      }
      updateHistoryState();
    }
  }, [historyStack, updateHistoryState]);

  const redo = useCallback(() => {
    const nextState = historyStack.redo();
    if (nextState) {
      setWriteup(nextState);
      if (writeupRef.current) {
        writeupRef.current.innerHTML = formatWriteupForDisplay(nextState);
      }
      updateHistoryState();
    }
  }, [historyStack, updateHistoryState]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable) {
        return;
      }
      
      if (event.ctrlKey && event.key === 'z' && !event.shiftKey) {
        event.preventDefault();
        if (canUndo) undo();
      } else if ((event.ctrlKey && event.key === 'y') || (event.ctrlKey && event.shiftKey && event.key === 'Z')) {
        event.preventDefault();
        if (canRedo) redo();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, canUndo, canRedo]);

  // Format writeup for display
  const formatWriteupForDisplay = (text) => {
    if (!text) return '';
    
    return text
      .replace(/\*\*([A-Z\s:]+)\*\*/g, '<h3 style="font-size: 18px; font-weight: 700; color: #1f2937; margin: 16px 0 8px 0; border-bottom: 1px solid #e5e7eb; padding-bottom: 4px;">$1</h3>')
      .replace(/\*\*([^*]+)\*\*/g, '<strong style="font-weight: 600; color: #374151;">$1</strong>')
      .replace(/\n• /g, '<br/>• ')
      .replace(/\n\n/g, '<br/><br/>')
      .replace(/\n/g, '<br/>');
  };

  // Apply user preferences
  const applyUserPreferences = useCallback((content) => {
    let modifiedContent = content;
    
    if (userPreferences.excludeMarketPositioning) {
      modifiedContent = modifiedContent.replace(/• Market Positioning:.*?\n/g, '');
      modifiedContent = modifiedContent.replace(/\*\*Market Position.*?\n\n/gs, '');
    }
    
    if (userPreferences.excludeIndustryBenchmarks) {
      modifiedContent = modifiedContent.replace(/• Industry comparison:.*?\n/g, '');
      modifiedContent = modifiedContent.replace(/vs Industry norm.*?\n/g, '\n');
    }
    
    if (userPreferences.excludeStrategy) {
      modifiedContent = modifiedContent.replace(/\*\*STRATEGIC RECOMMENDATIONS\*\*.*?(?=\*\*|$)/gs, '');
    }
    
    if (userPreferences.excludeTrends) {
      modifiedContent = modifiedContent.replace(/\(\s*[\+\-]?\d+\.\d+%\s*YoY\)/g, '');
      modifiedContent = modifiedContent.replace(/,\s*[\+\-]?\d+\.\d+%\s*YoY/g, '');
    }
    
    if (userPreferences.preferMT) {
      modifiedContent = modifiedContent.replace(/k tons?/g, 'MT');
    }
    
    return modifiedContent;
  }, [userPreferences]);

  // Generate detailed writeup
  const generateDetailedWriteup = useCallback(async () => {
    if (loading) return;

    setLoading(true);
    setError(null);
    setRegenerationFeedback('');

    try {
      function getKPI(rowIndex, period) {
        if (!period || !computeCellValue) return 0;
        try {
          const value = computeCellValue(rowIndex, period);
          return typeof value === 'number' && !isNaN(value) ? value : 0;
        } catch (err) {
          return 0;
        }
      }

      if (!basePeriod || !selectedPeriods || selectedPeriods.length === 0) {
        throw new Error('Missing required period data');
      }

      const basePeriodName = `${basePeriod.year} ${basePeriod.isCustomRange ? basePeriod.displayName : (basePeriod.month || '')} ${basePeriod.type}`.trim();
      const baseData = {
        sales: getKPI(3, basePeriod),
        material: getKPI(5, basePeriod),
        grossProfit: getKPI(4, basePeriod),
        mfgExpenses: getKPI(14, basePeriod),
        belowGP: getKPI(52, basePeriod),
        netProfit: getKPI(54, basePeriod),
        ebitda: getKPI(56, basePeriod),
        salesVolume: getKPI(7, basePeriod),
        labor: getKPI(15, basePeriod),
        electricity: getKPI(17, basePeriod),
        admin: getKPI(19, basePeriod),
      };

      const totalCosts = baseData.material + baseData.mfgExpenses + baseData.belowGP;
      const metrics = {
        grossMargin: baseData.sales > 0 ? (baseData.grossProfit / baseData.sales) * 100 : 0,
        netMargin: baseData.sales > 0 ? (baseData.netProfit / baseData.sales) * 100 : 0,
        ebitdaMargin: baseData.sales > 0 ? (baseData.ebitda / baseData.sales) * 100 : 0,
        materialRatio: baseData.sales > 0 ? (baseData.material / baseData.sales) * 100 : 0,
        mfgRatio: baseData.sales > 0 ? (baseData.mfgExpenses / baseData.sales) * 100 : 0,
        belowGPRatio: baseData.sales > 0 ? (baseData.belowGP / baseData.sales) * 100 : 0,
        laborRatio: baseData.sales > 0 ? (baseData.labor / baseData.sales) * 100 : 0,
        electricityRatio: baseData.sales > 0 ? (baseData.electricity / baseData.sales) * 100 : 0,
        adminRatio: baseData.sales > 0 ? (baseData.admin / baseData.sales) * 100 : 0,
        pricePerKg: baseData.salesVolume > 0 ? baseData.sales / baseData.salesVolume : 0,
        revenuePerTon: baseData.salesVolume > 0 ? baseData.sales / (baseData.salesVolume / 1000) : 0,
        materialCostPerTon: baseData.salesVolume > 0 ? baseData.material / (baseData.salesVolume / 1000) : 0,
        grossProfitPerTon: baseData.salesVolume > 0 ? baseData.grossProfit / (baseData.salesVolume / 1000) : 0,
        mfgCostPerTon: baseData.salesVolume > 0 ? baseData.mfgExpenses / (baseData.salesVolume / 1000) : 0,
        marginOverMaterial: baseData.material > 0 ? ((baseData.sales - baseData.material) / baseData.material) * 100 : 0,
        totalCosts: totalCosts,
        totalCostRatio: baseData.sales > 0 ? (totalCosts / baseData.sales) * 100 : 0,
      };

      let aiText = `**COMPREHENSIVE FINANCIAL ANALYSIS: ${basePeriodName}**\n`;
      aiText += `**${divisionNames[selectedDivision] || selectedDivision}**\n\n`;

      aiText += `**EXECUTIVE SUMMARY**\n\n`;
      aiText += `This analysis evaluates the financial performance of ${basePeriodName}. Key highlights include `;
      aiText += `a gross margin of ${metrics.grossMargin.toFixed(1)}% and a net margin of ${metrics.netMargin.toFixed(1)}%. `;
      aiText += `Performance metrics indicate areas for optimization in cost control and profitability.\n\n`;

      aiText += `**REVENUE & VOLUME ANALYSIS**\n`;
      aiText += `• Total Revenue: ${(baseData.sales / 1000000).toFixed(2)}M\n`;
      aiText += `• Sales Volume: ${(baseData.salesVolume / 1000).toFixed(1)} k tons\n`;
      aiText += `• Average Selling Price: ${metrics.pricePerKg.toFixed(3)}/kg\n`;
      aiText += `• Revenue per Ton: ${(metrics.revenuePerTon / 1000).toFixed(0)}K\n`;
      if (!userPreferences.excludeMarketPositioning) {
        aiText += `• Market Positioning: ${metrics.pricePerKg > 3.0 ? 'Premium pricing' : metrics.pricePerKg > 2.0 ? 'Competitive' : 'Value-focused'}\n`;
      }
      aiText += `\n`;

      aiText += `**PROFITABILITY ANALYSIS**\n`;
      aiText += `• Gross Profit: ${(baseData.grossProfit / 1000000).toFixed(2)}M (${metrics.grossMargin.toFixed(1)}% margin)\n`;
      aiText += `• EBITDA: ${(baseData.ebitda / 1000000).toFixed(2)}M (${metrics.ebitdaMargin.toFixed(1)}% margin)\n`;
      aiText += `• Net Profit: ${(baseData.netProfit / 1000000).toFixed(2)}M (${metrics.netMargin.toFixed(1)}% margin)\n`;
      aiText += `• Gross Profit per Ton: ${(metrics.grossProfitPerTon / 1000).toFixed(0)}K\n`;
      aiText += `\n`;

      aiText += `**COST STRUCTURE BREAKDOWN**\n`;
      aiText += `• Material Costs: ${(baseData.material / 1000000).toFixed(2)}M (${metrics.materialRatio.toFixed(1)}%/Sls)\n`;
      aiText += `• Manufacturing Expenses: ${(baseData.mfgExpenses / 1000000).toFixed(2)}M (${metrics.mfgRatio.toFixed(1)}%/Sls)\n`;
      aiText += `• Labor Costs: ${(baseData.labor / 1000000).toFixed(2)}M (${metrics.laborRatio.toFixed(1)}%/Sls)\n`;
      aiText += `• Electricity Costs: ${(baseData.electricity / 1000000).toFixed(2)}M (${metrics.electricityRatio.toFixed(1)}%/Sls)\n`;
      aiText += `• Admin Costs: ${(baseData.admin / 1000000).toFixed(2)}M (${metrics.adminRatio.toFixed(1)}%/Sls)\n`;
      aiText += `• Below Gross Profit Costs: ${(baseData.belowGP / 1000000).toFixed(2)}M (${metrics.belowGPRatio.toFixed(1)}%/Sls)\n`;
      aiText += `• Total Operating Costs: ${(metrics.totalCosts / 1000000).toFixed(2)}M (${metrics.totalCostRatio.toFixed(1)}%/Sls)\n`;
      aiText += `• Material Cost per Ton: ${(metrics.materialCostPerTon / 1000).toFixed(0)}K\n`;
      aiText += `\n`;

      if (!userPreferences.excludeStrategy) {
        aiText += `**STRATEGIC RECOMMENDATIONS**\n`;
        aiText += `• Cost Optimization: Reduce material costs by ${metrics.materialRatio > 70 ? '5-10%' : '2-5%'} through supplier negotiations\n`;
        aiText += `• Pricing Strategy: Adjust pricing to improve price per kg by ${metrics.pricePerKg < 2.0 ? '10-15%' : '5%'}\n`;
        aiText += `• Efficiency Improvement: Invest in automation to lower mfg costs by ${metrics.mfgRatio > 20 ? '10%' : '5%'}\n`;
        aiText += `\n`;
      }

      aiText += `**SCENARIO ANALYSIS SUGGESTION**\n`;
      aiText += `Use the chat to simulate scenarios (e.g., "What if material costs drop by 5%?") for deeper insights.\n`;

      const processedText = applyUserPreferences(aiText);
      
      // Add to history before setting new content
      if (writeup) {
        historyStack.push(writeup);
      }
      
      setWriteup(processedText);
      setHasAutoGenerated(true);
      updateHistoryState();

      setChatMessages(prev => [...prev, {
        type: 'system',
        content: `Analysis generated with ${Object.keys(userPreferences).length} learned preferences applied.`,
        timestamp: new Date(),
      }]);

    } catch (err) {
      console.error('Error generating writeup:', err);
      setError(`Failed to generate analysis: ${err.message}`);
    } finally {
      setLoading(false);
    }
  }, [basePeriod, selectedPeriods, computeCellValue, selectedDivision, divisionNames, userPreferences, applyUserPreferences, writeup, historyStack, updateHistoryState]);

  // Handle text selection
  const handleTextSelection = () => {
    const selection = window.getSelection();
    const selectedText = selection.toString().trim();
    if (selectedText.length > 0) {
      setSelectedText(selectedText);
      setShowChat(true);
    }
  };

  // Handle writeup edit
  const handleWriteupEdit = debounce((newContent) => {
    if (newContent !== writeup) {
      historyStack.push(writeup);
      setWriteup(newContent);
      updateHistoryState();
    }
  }, 500);

  // Handle export
  const handleExport = async () => {
    setIsExporting(true);
    try {
      await exportWriteup(writeup, exportFormat);
      setShowExportOptions(false);
    } catch (error) {
      console.error('Export failed:', error);
    } finally {
      setIsExporting(false);
    }
  };

  // Scroll chat to bottom
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [chatMessages]);

  return (
    <div className="writeup-view-container">
      <div className="writeup-main-content">
        {/* Header */}
        <div className="writeup-header">
          <div>
            <h2>Financial Analysis Write-up</h2>
            <div className="division-name">
              {divisionNames[selectedDivision] || selectedDivision}
            </div>
          </div>
          <div className="header-controls">
            {/* Undo/Redo buttons */}
            <button 
              onClick={undo}
              disabled={!canUndo}
              title="Undo (Ctrl+Z)"
              className={`control-btn ${canUndo ? 'enabled' : 'disabled'}`}
            >
              ↶ Undo
            </button>
            <button 
              onClick={redo}
              disabled={!canRedo}
              title="Redo (Ctrl+Y)"
              className={`control-btn ${canRedo ? 'enabled' : 'disabled'}`}
            >
              ↷ Redo
            </button>
            
            {/* Export button */}
            <div className="export-dropdown">
              <button
                onClick={() => setShowExportOptions(!showExportOptions)}
                className="control-btn export-btn"
              >
                📤 Export
              </button>
              
              {showExportOptions && (
                <div className="export-options">
                  <h4>Export Format</h4>
                  <label>
                    <input
                      type="radio"
                      name="exportFormat"
                      value="pdf"
                      checked={exportFormat === 'pdf'}
                      onChange={() => setExportFormat('pdf')}
                    />
                    PDF Document
                  </label>
                  <label>
                    <input
                      type="radio"
                      name="exportFormat"
                      value="txt"
                      checked={exportFormat === 'txt'}
                      onChange={() => setExportFormat('txt')}
                    />
                    Plain Text (.txt)
                  </label>
                  <label>
                    <input
                      type="radio"
                      name="exportFormat"
                      value="markdown"
                      checked={exportFormat === 'markdown'}
                      onChange={() => setExportFormat('markdown')}
                    />
                    Markdown (.md)
                  </label>
                  <div className="export-actions">
                    <button onClick={() => setShowExportOptions(false)}>Cancel</button>
                    <button onClick={handleExport} disabled={isExporting}>
                      {isExporting ? 'Exporting...' : 'Export'}
                    </button>
                  </div>
                </div>
              )}
            </div>
            
            <button
              onClick={() => setShowPreferences(!showPreferences)}
              className={`control-btn ${showPreferences ? 'active' : ''}`}
            >
              Preferences ({Object.keys(userPreferences).length})
            </button>
            <button
              onClick={() => setShowChat(!showChat)}
              className={`control-btn ${showChat ? 'active' : ''}`}
            >
              {showChat ? 'Hide Chat' : 'Show Chat'}
            </button>
          </div>
        </div>

        {/* Status messages */}
        {error && <div className="status-message error">{error}</div>}
        {regenerationFeedback && (
          <div className={`status-message ${regenerationFeedback.startsWith('✅') ? 'success' : 'info'}`}>
            {regenerationFeedback}
          </div>
        )}

        {/* Instructions */}
        <div className="instructions-panel">
          <strong>📝 How to Use the AI Writing Assistant:</strong>
          <div>
            <div>1. <strong>Generate Analysis:</strong> Click "Generate Analysis" to create your writeup</div>
            <div>2. <strong>Select Text:</strong> Highlight any part of the analysis to discuss</div>
            <div>3. <strong>Open Chat:</strong> Click "Show Chat" (opens automatically with selection)</div>
            <div>4. <strong>Ask AI:</strong> Expand, correct, remove text, set preferences, or simulate scenarios</div>
            <div className="tip">💡 <strong>Tip:</strong> Selected text appears in a blue box in the chat!</div>
          </div>
        </div>

        {/* Writeup editor */}
        <div className="writeup-content">
          <div
            ref={writeupRef}
            contentEditable
            suppressContentEditableWarning
            onMouseUp={handleTextSelection}
            onInput={(e) => handleWriteupEdit(e.currentTarget.innerText)}
            className="writeup-editor"
            spellCheck={true}
          >
            {writeup ? (
              <div dangerouslySetInnerHTML={{ __html: formatWriteupForDisplay(writeup) }} />
            ) : (
              <div className="placeholder-text">
                Click "Generate Analysis" to create a comprehensive financial analysis. Use the chat to expand, correct, remove text, simulate scenarios, or recall past requests.
              </div>
            )}
          </div>
        </div>

        {/* Action buttons */}
        <div className="action-buttons">
          {selectedText && (
            <button
              onClick={() => {
                if (!selectedText) {
                  alert('Please select some text in the writeup above first.');
                }
              }}
              className="capture-btn"
            >
              📌 Capture Selected Text
            </button>
          )}
          <button
            onClick={generateDetailedWriteup}
            disabled={loading}
            className="generate-btn"
          >
            {loading ? 'Generating...' : 'Generate Analysis'}
          </button>
        </div>
      </div>

      {/* Chat Panel */}
      {showChat && (
        <div className="chat-panel">
          <h3>AI Writing Assistant</h3>
          
          {selectedText && (
            <div className="selected-text-display">
              <div>
                <strong>📌 Selected Text:</strong><br/>
                <span className="selected-text">
                  "{selectedText.length > 150 ? selectedText.substring(0, 150) + '...' : selectedText}"
                </span>
                <div className="selected-text-hint">
                  💬 Expand, correct, remove, simulate scenarios, or recall past requests
                </div>
              </div>
              <button
                onClick={() => setSelectedText('')}
                className="clear-selection-btn"
              >
                Clear
              </button>
            </div>
          )}
          
          {!selectedText && (
            <div className="chat-hint">
              💡 Select text above or type a request below
            </div>
          )}
          
          <div className="chat-messages">
            {chatMessages.map((message, index) => (
              <div
                key={index}
                className={`chat-message ${message.type}`}
              >
                <div className="message-header">
                  {message.type === 'user' ? 'You' : message.type === 'error' ? 'Error' : 'AI Assistant'} - {message.timestamp.toLocaleString()}
                </div>
                <div className="message-content">
                  {message.content}
                </div>
              </div>
            ))}
            {chatLoading && (
              <div className="chat-loading">
                AI is thinking...
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>
          
          <form className="chat-form">
            <textarea
              ref={chatInputRef}
              value={currentPrompt}
              onChange={(e) => setCurrentPrompt(e.target.value)}
              placeholder="Expand (e.g., 'Expand on costs'), correct (e.g., 'Change X to Y'), remove (e.g., 'Remove this text'), set preferences (e.g., 'Focus on margins'), simulate (e.g., 'What if mfg costs by 5%?')..."
              className="chat-input"
              disabled={chatLoading}
            />
            <button
              type="submit"
              disabled={chatLoading || !currentPrompt.trim()}
              className="chat-send-btn"
            >
              {chatLoading ? 'Processing...' : 'Send'}
            </button>
          </form>
          
          <div className="chat-help">
            💡 <strong>Expansion:</strong> "Expand on profitability"<br/>
            🧠 <strong>Preferences:</strong> "Focus on costs", "Use MT"<br/>
            ✏️ <strong>Corrections:</strong> "Change X to Y"<br/>
            🗑️ <strong>Remove:</strong> "Remove this text"<br/>
            📊 <strong>Scenarios:</strong> "What if material costs by 5%?"
          </div>
        </div>
      )}

      {/* Preferences Panel */}
      {showPreferences && (
        <div className="preferences-panel">
          <h3>🧠 Learned Preferences for {divisionNames[selectedDivision] || selectedDivision}</h3>
          
          {Object.keys(userPreferences).length === 0 ? (
            <p className="no-preferences">
              No preferences learned yet. Use the chat to teach preferences (e.g., "Focus on costs", "Remove this text").
            </p>
          ) : (
            <div>
              <div className="preferences-list">
                <strong>Current Preferences:</strong>
                {Object.entries(userPreferences).map(([key, value]) => {
                  if (!value) return null;
                  const getPreferenceDescription = (prefKey) => {
                    const descriptions = {
                      excludeMarketPositioning: '🚫 Exclude market positioning',
                      excludeIndustryBenchmarks: '🚫 Exclude industry benchmarks',
                      excludeStrategy: '🚫 Exclude strategic recommendations',
                      excludeTrends: '🚫 Exclude trend and YoY comparisons',
                      focusOnCosts: '🎯 Focus on cost analysis',
                      focusOnMargins: '🎯 Focus on margin analysis',
                      preferShortFormat: '📝 Prefer short format',
                      preferDetailedFormat: '📝 Prefer detailed format',
                      preferMT: '📏 Use MT units',
                    };
                    return descriptions[prefKey] || prefKey;
                  };
                  return (
                    <div key={key} className="preference-item">
                      <span>{getPreferenceDescription(key)}</span>
                      <button
                        onClick={() => {
                          const newPreferences = { ...userPreferences };
                          delete newPreferences[key];
                          setUserPreferences(newPreferences);
                        }}
                        className="remove-preference-btn"
                      >
                        Remove
                      </button>
                    </div>
                  );
                })}
              </div>
              <div className="preferences-actions">
                <button
                  onClick={() => {
                    setUserPreferences({});
                    localStorage.removeItem(`aiWriteupPreferences_${selectedDivision}`);
                  }}
                  className="clear-all-preferences-btn"
                >
                  Clear All Preferences
                </button>
                <span className="preferences-note">
                  Preferences persist across sessions
                </span>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default WriteUpView; 