import React, { useState, useEffect } from 'react';

// Placeholder async backend API functions
async function fetchWriteup(periodKey, division) {
  // TODO: Replace with real API call
  return null;
}
async function saveWriteup(periodKey, division, text) {
  // TODO: Replace with real API call
  return true;
}

function getPeriodKey(selectedPeriods) {
  return selectedPeriods.map(p => `${p.year}-${p.month || 'Year'}-${p.type}`).join('|');
}

const AIWriteupPanel = ({ tableData, selectedPeriods, basePeriod, division, chatContext, computeCellValue }) => {
  const [writeup, setWriteup] = useState('');
  const [loading, setLoading] = useState(false);
  const [editing, setEditing] = useState(false);
  const [error, setError] = useState(null);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [generationCount, setGenerationCount] = useState(0);

  const periodKey = getPeriodKey(selectedPeriods);

  // Hardcoded worldwide norms for each division
  const divisionNorms = {
    FP: {
      marginOverMaterial: 18, // %
      grossProfit: 15, // %
      netProfit: 7, // %
      ebitda: 12 // %
    },
    SB: {
      marginOverMaterial: 14,
      grossProfit: 12,
      netProfit: 5,
      ebitda: 9
    },
    TF: {
      marginOverMaterial: 16,
      grossProfit: 13,
      netProfit: 6,
      ebitda: 10
    },
    HCM: {
      marginOverMaterial: 20,
      grossProfit: 17,
      netProfit: 8,
      ebitda: 13
    }
  };

  // Division full names
  const divisionNames = {
    FP: 'Flexible Packaging Division',
    SB: 'Shopping Bags Division',
    TF: 'Thermoforming Products Division',
    HCM: 'Preforms and Closures Division'
  };

  async function generateAIWriteup() {
    // Prevent multiple simultaneous calls
    if (loading) {
      console.log('Generation already in progress, ignoring call');
      return;
    }
    
    console.log('Starting writeup generation...');
    setLoading(true);
    setError(null);
    
    // Safety timeout to reset loading state after 30 seconds
    const timeoutId = setTimeout(() => {
      console.warn('Generation timeout - forcing loading state reset');
      setLoading(false);
      setError('Generation timed out. Please try again.');
    }, 30000);
    
    try {
      // Helper to get KPI value for a period using computeCellValue
      function getKPI(rowIndex, period) {
        if (!period || !computeCellValue) return 0;
        try {
          const value = computeCellValue(rowIndex, period);
          return typeof value === 'number' && !isNaN(value) ? value : 0;
        } catch (err) {
          console.error(`Error getting KPI for row ${rowIndex}:`, err);
          return 0;
        }
      }
      
      // Validate required data
      if (!basePeriod || !selectedPeriods || selectedPeriods.length === 0) {
        throw new Error('Missing required period data');
      }
      
      // Row indices for key KPIs
      const ROWS = {
        sales: 3,
        material: 5,
        grossProfit: 4,
        mfgExpenses: 14,
        belowGP: 52,
        netProfit: 54,
        ebitda: 56,
        salesVolume: 7
      };
      
      // Get base period values and name
      const basePeriodName = `${basePeriod.year} ${basePeriod.month || ''} ${basePeriod.type}`.trim();
      const base = {
        sales: getKPI(ROWS.sales, basePeriod),
        material: getKPI(ROWS.material, basePeriod),
        grossProfit: getKPI(ROWS.grossProfit, basePeriod),
        mfgExpenses: getKPI(ROWS.mfgExpenses, basePeriod),
        belowGP: getKPI(ROWS.belowGP, basePeriod),
        netProfit: getKPI(ROWS.netProfit, basePeriod),
        ebitda: getKPI(ROWS.ebitda, basePeriod),
        salesVolume: getKPI(ROWS.salesVolume, basePeriod)
      };
      
      // Validate base period has data
      if (base.sales === 0) {
        throw new Error('No sales data available for base period');
      }
      
      console.log('Base period data loaded successfully');
      
      // Find previous year period (same month/type, previous year)
      const prevYearPeriod = selectedPeriods.find(p => 
        p.year === basePeriod.year - 1 && 
        p.month === basePeriod.month && 
        p.type === basePeriod.type
      );
      
      // Find budget period (same year/month, Budget type)
      const budgetPeriod = selectedPeriods.find(p => 
        p.year === basePeriod.year && 
        p.month === basePeriod.month && 
        p.type === 'Budget'
      );
      
      let prevYear = null;
      let prevYearName = '';
      if (prevYearPeriod) {
        prevYearName = `${prevYearPeriod.year} ${prevYearPeriod.month || ''} ${prevYearPeriod.type}`.trim();
        prevYear = {
          sales: getKPI(ROWS.sales, prevYearPeriod),
          material: getKPI(ROWS.material, prevYearPeriod),
          grossProfit: getKPI(ROWS.grossProfit, prevYearPeriod),
          mfgExpenses: getKPI(ROWS.mfgExpenses, prevYearPeriod),
          belowGP: getKPI(ROWS.belowGP, prevYearPeriod),
          netProfit: getKPI(ROWS.netProfit, prevYearPeriod),
          ebitda: getKPI(ROWS.ebitda, prevYearPeriod),
          salesVolume: getKPI(ROWS.salesVolume, prevYearPeriod)
        };
      }
      
      let budget = null;
      let budgetName = '';
      if (budgetPeriod) {
        budgetName = `${budgetPeriod.year} ${budgetPeriod.month || ''} ${budgetPeriod.type}`.trim();
        budget = {
          sales: getKPI(ROWS.sales, budgetPeriod),
          material: getKPI(ROWS.material, budgetPeriod),
          grossProfit: getKPI(ROWS.grossProfit, budgetPeriod),
          mfgExpenses: getKPI(ROWS.mfgExpenses, budgetPeriod),
          belowGP: getKPI(ROWS.belowGP, budgetPeriod),
          netProfit: getKPI(ROWS.netProfit, budgetPeriod),
          ebitda: getKPI(ROWS.ebitda, budgetPeriod),
          salesVolume: getKPI(ROWS.salesVolume, budgetPeriod)
        };
      }
      
      // Calculate metrics vs previous year
      let yoyMetrics = {};
      if (prevYear && prevYear.sales > 0) {
        yoyMetrics = {
          salesChange: ((base.sales - prevYear.sales) / prevYear.sales) * 100,
          volumeChange: prevYear.salesVolume > 0 ? ((base.salesVolume - prevYear.salesVolume) / prevYear.salesVolume) * 100 : 0,
          volumeChangeTons: (base.salesVolume - prevYear.salesVolume) / 1000,
          pricePerKgBase: prevYear.salesVolume > 0 ? prevYear.sales / prevYear.salesVolume : 0,
          pricePerKgCurrent: base.salesVolume > 0 ? base.sales / base.salesVolume : 0,
          materialRatioPY: (prevYear.material / prevYear.sales) * 100,
          materialRatioCurrent: (base.material / base.sales) * 100,
          npMarginPY: (prevYear.netProfit / prevYear.sales) * 100,
          npMarginCurrent: (base.netProfit / base.sales) * 100,
          ebitdaMarginPY: (prevYear.ebitda / prevYear.sales) * 100,
          ebitdaMarginCurrent: (base.ebitda / base.sales) * 100,
          mfgRatioPY: (prevYear.mfgExpenses / prevYear.sales) * 100,
          mfgRatioCurrent: (base.mfgExpenses / base.sales) * 100
        };
        yoyMetrics.pricePerKgChange = yoyMetrics.pricePerKgCurrent - yoyMetrics.pricePerKgBase;
        yoyMetrics.materialRatioPP = yoyMetrics.materialRatioCurrent - yoyMetrics.materialRatioPY;
        yoyMetrics.npMarginPP = yoyMetrics.npMarginCurrent - yoyMetrics.npMarginPY;
        yoyMetrics.ebitdaMarginPP = yoyMetrics.ebitdaMarginCurrent - yoyMetrics.ebitdaMarginPY;
        yoyMetrics.mfgRatioPP = yoyMetrics.mfgRatioCurrent - yoyMetrics.mfgRatioPY;

        // Add volume-price-cost impact bridge
        const salesVolumeEffect = (base.salesVolume - prevYear.salesVolume) * yoyMetrics.pricePerKgBase;
        const salesPriceEffect = base.salesVolume * (yoyMetrics.pricePerKgCurrent - yoyMetrics.pricePerKgBase);
        yoyMetrics.volumePriceSalesBridge = {
          volume: salesVolumeEffect / 1000000,
          price: salesPriceEffect / 1000000
        };
      }
      
      // Calculate metrics vs budget
      let budgetMetrics = {};
      if (budget && budget.sales > 0) {
        budgetMetrics = {
          salesVariance: ((base.sales - budget.sales) / budget.sales) * 100,
          salesVarianceMM: (base.sales - budget.sales) / 1000000,
          volumeVariance: budget.salesVolume > 0 ? ((base.salesVolume - budget.salesVolume) / budget.salesVolume) * 100 : 0,
          volumeVarianceTons: (base.salesVolume - budget.salesVolume) / 1000,
          pricePerKgBudget: budget.salesVolume > 0 ? budget.sales / budget.salesVolume : 0,
          pricePerKgActual: base.salesVolume > 0 ? base.sales / base.salesVolume : 0,
          materialRatioBudget: (budget.material / budget.sales) * 100,
          materialRatioActual: (base.material / base.sales) * 100,
          npMarginBudget: (budget.netProfit / budget.sales) * 100,
          npMarginActual: (base.netProfit / base.sales) * 100,
          netProfitVarianceMM: (base.netProfit - budget.netProfit) / 1000000,
          mfgRatioBudget: (budget.mfgExpenses / budget.sales) * 100,
          mfgRatioActual: (base.mfgExpenses / base.sales) * 100
        };
        budgetMetrics.pricePerKgVariance = budgetMetrics.pricePerKgActual - budgetMetrics.pricePerKgBudget;
        budgetMetrics.materialRatioPP = budgetMetrics.materialRatioActual - budgetMetrics.materialRatioBudget;
        budgetMetrics.npMarginPP = budgetMetrics.npMarginActual - budgetMetrics.npMarginBudget;
        budgetMetrics.mfgRatioPP = budgetMetrics.mfgRatioActual - budgetMetrics.mfgRatioBudget;

        // Add profit variance bridge
        const profitVolumeEffect = (base.salesVolume - budget.salesVolume) * (budget.sales / budget.salesVolume - budget.material / budget.salesVolume - budget.mfgExpenses / budget.salesVolume);
        const profitPriceEffect = base.salesVolume * (budgetMetrics.pricePerKgActual - budgetMetrics.pricePerKgBudget);
        const profitMaterialCostEffect = budget.material - base.material;
        const profitMfgCostEffect = budget.mfgExpenses - base.mfgExpenses;
        
        budgetMetrics.profitVarianceBridge = {
          volume: profitVolumeEffect / 1000000,
          price: profitPriceEffect / 1000000,
          materialCost: profitMaterialCostEffect / 1000000,
          mfgCost: profitMfgCostEffect / 1000000
        };
      }
      
      console.log('Calculations completed, generating text...');
      
      // SYSTEMATIC ANALYSIS STRUCTURE - Enhanced Approach
      
      // 1. SEQUENTIAL PERIOD ANALYSIS - Find precedent and subsequent periods
      const sortedAllPeriods = selectedPeriods.sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        if (a.month && b.month) return a.month - b.month;
        return a.type === 'Actual' ? -1 : 1; // Actual before Budget for same month
      });
      
      const basePeriodIndex = sortedAllPeriods.findIndex(p => p === basePeriod);
      const precedentPeriod = basePeriodIndex > 0 ? sortedAllPeriods[basePeriodIndex - 1] : null;
      const subsequentPeriod = basePeriodIndex < sortedAllPeriods.length - 1 ? sortedAllPeriods[basePeriodIndex + 1] : null;
      
      // 2. COMPREHENSIVE KPI EXTRACTION for all relevant periods
      function getComprehensiveKPIs(period) {
        if (!period) return null;
        const sales = getKPI(ROWS.sales, period);
        const material = getKPI(ROWS.material, period);
        const grossProfit = getKPI(ROWS.grossProfit, period);
        const mfgExpenses = getKPI(ROWS.mfgExpenses, period);
        const belowGP = getKPI(ROWS.belowGP, period);
        const netProfit = getKPI(ROWS.netProfit, period);
        const ebitda = getKPI(ROWS.ebitda, period);
        const salesVolume = getKPI(ROWS.salesVolume, period);
        
        return {
          // Core Financial Metrics
          sales,
          material,
          grossProfit,
          mfgExpenses,
          belowGP,
          netProfit,
          ebitda,
          salesVolume,
          
          // Calculated Ratios
          grossMargin: sales > 0 ? (grossProfit / sales) * 100 : 0,
          netMargin: sales > 0 ? (netProfit / sales) * 100 : 0,
          ebitdaMargin: sales > 0 ? (ebitda / sales) * 100 : 0,
          materialRatio: sales > 0 ? (material / sales) * 100 : 0,
          mfgRatio: sales > 0 ? (mfgExpenses / sales) * 100 : 0,
          belowGPRatio: sales > 0 ? (belowGP / sales) * 100 : 0,
          pricePerKg: salesVolume > 0 ? sales / salesVolume : 0,
          revenuePerTon: salesVolume > 0 ? sales / (salesVolume / 1000) : 0,
          materialCostPerTon: salesVolume > 0 ? material / (salesVolume / 1000) : 0,
          grossProfitPerTon: salesVolume > 0 ? grossProfit / (salesVolume / 1000) : 0,
          
          periodName: `${period.year} ${period.month || ''} ${period.type}`.trim()
        };
      }
      
      const baseKPIs = getComprehensiveKPIs(basePeriod);
      const precedentKPIs = getComprehensiveKPIs(precedentPeriod);
      const subsequentKPIs = getComprehensiveKPIs(subsequentPeriod);
      
      // 3. HISTORICAL ANALYSIS - Multi-year context
      const historicalPeriods = selectedPeriods.filter(p => 
        p.type === 'Actual' && p.year < basePeriod.year
      ).sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        if (a.month && b.month) return a.month - b.month;
        return 0;
      });
      
      const historicalKPIs = historicalPeriods.map(p => getComprehensiveKPIs(p)).filter(k => k && k.sales > 0);
      
      // Helper function for variance calculation
      function calculateVariance(current, previous, metric) {
        if (!current || !previous || current[metric] === 0 || previous[metric] === 0) return null;
        if (metric.includes('Margin') || metric.includes('Ratio')) {
          return current[metric] - previous[metric]; // Percentage points for ratios
        } else {
          return ((current[metric] - previous[metric]) / previous[metric]) * 100; // Percentage change for absolute values
        }
      }
      
      // Start comprehensive analysis - single deep generation
      let aiText = `**COMPREHENSIVE PERFORMANCE ANALYSIS: ${basePeriodName}**\n`;
      aiText += `**${divisionNames[division] || division}**\n\n`;
      
      // EXECUTIVE SUMMARY
      aiText += `**EXECUTIVE SUMMARY:**\n\n`;
      aiText += `This comprehensive analysis examines ${basePeriodName} performance through systematic comparisons with adjacent periods and historical context. The analysis provides detailed insights into sales dynamics, profitability drivers, cost structure evolution, unit economics, and strategic performance trends.\n\n`;
      
      // CURRENT PERIOD PERFORMANCE BASELINE
      aiText += `**BASELINE PERFORMANCE METRICS - ${basePeriodName}:**\n\n`;
      aiText += `**Financial Overview:**\n`;
      aiText += `• Revenue: ${(baseKPIs.sales/1000000).toFixed(1)}M (${(baseKPIs.salesVolume/1000).toFixed(1)}k tons at ${baseKPIs.pricePerKg.toFixed(3)}/kg)\n`;
      aiText += `• Gross Profit: ${(baseKPIs.grossProfit/1000000).toFixed(1)}M (${baseKPIs.grossMargin.toFixed(1)}% margin)\n`;
      aiText += `• EBITDA: ${(baseKPIs.ebitda/1000000).toFixed(1)}M (${baseKPIs.ebitdaMargin.toFixed(1)}% margin)\n`;
      aiText += `• Net Profit: ${(baseKPIs.netProfit/1000000).toFixed(1)}M (${baseKPIs.netMargin.toFixed(1)}% margin)\n\n`;
      
      aiText += `**Cost Structure:**\n`;
      aiText += `• Material Costs: ${(baseKPIs.material/1000000).toFixed(1)}M (${baseKPIs.materialRatio.toFixed(1)}% of sales)\n`;
      aiText += `• Manufacturing: ${(baseKPIs.mfgExpenses/1000000).toFixed(1)}M (${baseKPIs.mfgRatio.toFixed(1)}% of sales)\n`;
      aiText += `• Below-GP Costs: ${(baseKPIs.belowGP/1000000).toFixed(1)}M (${baseKPIs.belowGPRatio.toFixed(1)}% of sales)\n\n`;
      
      aiText += `**Unit Economics:**\n`;
      aiText += `• Revenue per ton: ${(baseKPIs.revenuePerTon/1000).toFixed(0)}k\n`;
      aiText += `• Material cost per ton: ${(baseKPIs.materialCostPerTon/1000).toFixed(0)}k\n`;
      aiText += `• Gross profit per ton: ${(baseKPIs.grossProfitPerTon/1000).toFixed(0)}k\n\n`;
      
      // 1. BASE vs PREVIOUS PERIOD ANALYSIS
      if (precedentKPIs) {
        aiText += `**I. PERFORMANCE vs PREVIOUS PERIOD:**\n`;
        aiText += `**${basePeriodName} compared to ${precedentKPIs.periodName}**\n\n`;
        
        // Sales & Revenue Analysis
        const salesChange = calculateVariance(baseKPIs, precedentKPIs, 'sales');
        const volumeChange = calculateVariance(baseKPIs, precedentKPIs, 'salesVolume');
        const priceChange = baseKPIs.pricePerKg - precedentKPIs.pricePerKg;
        const volumeRevImpact = volumeChange !== null ? (volumeChange/100 * precedentKPIs.sales / 1000000) : 0;
        const priceRevImpact = priceChange * baseKPIs.salesVolume / 1000000;
        
        aiText += `**Revenue Performance Analysis:**\n`;
        aiText += `• Sales Performance: ${(precedentKPIs.sales/1000000).toFixed(1)}M → ${(baseKPIs.sales/1000000).toFixed(1)}M\n`;
        aiText += `  - Change: ${salesChange !== null ? (salesChange > 0 ? '+' : '') + salesChange.toFixed(1) + '%' : 'N/A'} (${((baseKPIs.sales - precedentKPIs.sales)/1000000) > 0 ? '+' : ''}${((baseKPIs.sales - precedentKPIs.sales)/1000000).toFixed(1)}M)\n`;
        aiText += `  - Assessment: ${salesChange > 5 ? 'STRONG growth momentum' : salesChange > 0 ? 'Positive growth trend' : salesChange > -5 ? 'Slight decline' : 'Concerning revenue drop'}\n\n`;
        
        aiText += `• Volume Analysis: ${(precedentKPIs.salesVolume/1000).toFixed(1)}k → ${(baseKPIs.salesVolume/1000).toFixed(1)}k tons\n`;
        aiText += `  - Change: ${volumeChange !== null ? (volumeChange > 0 ? '+' : '') + volumeChange.toFixed(1) + '%' : 'N/A'} (${((baseKPIs.salesVolume - precedentKPIs.salesVolume)/1000) > 0 ? '+' : ''}${((baseKPIs.salesVolume - precedentKPIs.salesVolume)/1000).toFixed(1)}k tons)\n`;
        aiText += `  - Impact on revenue: ${volumeRevImpact > 0 ? '+' : ''}${volumeRevImpact.toFixed(1)}M\n`;
        aiText += `  - Volume assessment: ${volumeChange > 3 ? 'Strong volume expansion indicates market growth or share gains' : volumeChange > 0 ? 'Modest volume increase shows stable demand' : volumeChange > -3 ? 'Slight volume decline may be temporary' : 'Significant volume drop requires urgent attention'}\n\n`;
        
        aiText += `• Pricing Analysis: ${precedentKPIs.pricePerKg.toFixed(3)} → ${baseKPIs.pricePerKg.toFixed(3)}/kg\n`;
        aiText += `  - Change: ${priceChange > 0 ? '+' : ''}${priceChange.toFixed(3)}/kg (${(priceChange/precedentKPIs.pricePerKg*100).toFixed(1)}%)\n`;
        aiText += `  - Impact on revenue: ${priceRevImpact > 0 ? '+' : ''}${priceRevImpact.toFixed(1)}M\n`;
        aiText += `  - Pricing power: ${priceChange > 0.1 ? 'EXCELLENT - Strong pricing discipline and market power' : priceChange > 0 ? 'Good pricing maintenance' : priceChange > -0.1 ? 'Stable pricing environment' : 'Pricing pressure challenges'}\n\n`;
        
        // Profitability Analysis
        const gmChange = baseKPIs.grossMargin - precedentKPIs.grossMargin;
        const nmChange = baseKPIs.netMargin - precedentKPIs.netMargin;
        const ebitdaChange = baseKPIs.ebitdaMargin - precedentKPIs.ebitdaMargin;
        
        aiText += `**Profitability Analysis:**\n`;
        aiText += `• Gross Margin: ${precedentKPIs.grossMargin.toFixed(1)}% → ${baseKPIs.grossMargin.toFixed(1)}%\n`;
        aiText += `  - Change: ${gmChange > 0 ? '+' : ''}${gmChange.toFixed(1)} percentage points\n`;
        aiText += `  - Gross profit: ${(precedentKPIs.grossProfit/1000000).toFixed(1)}M → ${(baseKPIs.grossProfit/1000000).toFixed(1)}M (${((baseKPIs.grossProfit - precedentKPIs.grossProfit)/precedentKPIs.grossProfit*100) > 0 ? '+' : ''}${((baseKPIs.grossProfit - precedentKPIs.grossProfit)/precedentKPIs.grossProfit*100).toFixed(1)}%)\n`;
        aiText += `  - Performance: ${gmChange > 1 ? 'EXCELLENT margin expansion' : gmChange > 0 ? 'Positive margin improvement' : gmChange > -1 ? 'Stable margin performance' : 'Margin compression concerns'}\n\n`;
        
        aiText += `• EBITDA Margin: ${precedentKPIs.ebitdaMargin.toFixed(1)}% → ${baseKPIs.ebitdaMargin.toFixed(1)}%\n`;
        aiText += `  - Change: ${ebitdaChange > 0 ? '+' : ''}${ebitdaChange.toFixed(1)} percentage points\n`;
        aiText += `  - EBITDA: ${(precedentKPIs.ebitda/1000000).toFixed(1)}M → ${(baseKPIs.ebitda/1000000).toFixed(1)}M (${((baseKPIs.ebitda - precedentKPIs.ebitda)/precedentKPIs.ebitda*100) > 0 ? '+' : ''}${((baseKPIs.ebitda - precedentKPIs.ebitda)/precedentKPIs.ebitda*100).toFixed(1)}%)\n`;
        
        aiText += `• Net Margin: ${precedentKPIs.netMargin.toFixed(1)}% → ${baseKPIs.netMargin.toFixed(1)}%\n`;
        aiText += `  - Change: ${nmChange > 0 ? '+' : ''}${nmChange.toFixed(1)} percentage points\n`;
        aiText += `  - Net profit: ${(precedentKPIs.netProfit/1000000).toFixed(1)}M → ${(baseKPIs.netProfit/1000000).toFixed(1)}M (${((baseKPIs.netProfit - precedentKPIs.netProfit)/precedentKPIs.netProfit*100) > 0 ? '+' : ''}${((baseKPIs.netProfit - precedentKPIs.netProfit)/precedentKPIs.netProfit*100).toFixed(1)}%)\n`;
        aiText += `  - Bottom line performance: ${nmChange > 1 ? 'OUTSTANDING profit improvement' : nmChange > 0 ? 'Solid profitability gains' : nmChange > -1 ? 'Stable profitability' : 'Profitability challenges requiring attention'}\n\n`;
        
        // Cost Analysis
        const materialRatioChange = baseKPIs.materialRatio - precedentKPIs.materialRatio;
        const mfgRatioChange = baseKPIs.mfgRatio - precedentKPIs.mfgRatio;
        const materialCostPerTonChange = baseKPIs.materialCostPerTon - precedentKPIs.materialCostPerTon;
        
        aiText += `**Cost Structure Analysis:**\n`;
        aiText += `• Material Costs: ${(precedentKPIs.material/1000000).toFixed(1)}M → ${(baseKPIs.material/1000000).toFixed(1)}M\n`;
        aiText += `  - Absolute change: ${((baseKPIs.material - precedentKPIs.material)/precedentKPIs.material*100) > 0 ? '+' : ''}${((baseKPIs.material - precedentKPIs.material)/precedentKPIs.material*100).toFixed(1)}%\n`;
        aiText += `  - As % of sales: ${precedentKPIs.materialRatio.toFixed(1)}% → ${baseKPIs.materialRatio.toFixed(1)}% (${materialRatioChange > 0 ? '+' : ''}${materialRatioChange.toFixed(1)} pp)\n`;
        aiText += `  - Cost per ton: ${(precedentKPIs.materialCostPerTon/1000).toFixed(0)}k → ${(baseKPIs.materialCostPerTon/1000).toFixed(0)}k (${materialCostPerTonChange > 0 ? '+' : ''}${(materialCostPerTonChange/1000).toFixed(0)}k)\n`;
        aiText += `  - Cost efficiency: ${materialRatioChange < -0.5 ? 'EXCELLENT cost control achieved' : materialRatioChange < 0 ? 'Good cost management' : materialRatioChange < 0.5 ? 'Stable cost structure' : 'Cost inflation pressures evident'}\n\n`;
        
        aiText += `• Manufacturing Costs: ${(precedentKPIs.mfgExpenses/1000000).toFixed(1)}M → ${(baseKPIs.mfgExpenses/1000000).toFixed(1)}M\n`;
        aiText += `  - Absolute change: ${((baseKPIs.mfgExpenses - precedentKPIs.mfgExpenses)/precedentKPIs.mfgExpenses*100) > 0 ? '+' : ''}${((baseKPIs.mfgExpenses - precedentKPIs.mfgExpenses)/precedentKPIs.mfgExpenses*100).toFixed(1)}%\n`;
        aiText += `  - As % of sales: ${precedentKPIs.mfgRatio.toFixed(1)}% → ${baseKPIs.mfgRatio.toFixed(1)}% (${mfgRatioChange > 0 ? '+' : ''}${mfgRatioChange.toFixed(1)} pp)\n`;
        aiText += `  - Operational leverage: ${mfgRatioChange < -0.5 ? 'Strong operational leverage achieved through scale' : mfgRatioChange < 0 ? 'Good manufacturing efficiency gains' : mfgRatioChange < 0.5 ? 'Stable manufacturing performance' : 'Manufacturing efficiency challenges'}\n\n`;
        
        // Unit Economics
        const revenuePerTonChange = baseKPIs.revenuePerTon - precedentKPIs.revenuePerTon;
        const gpPerTonChange = baseKPIs.grossProfitPerTon - precedentKPIs.grossProfitPerTon;
        
        aiText += `**Unit Economics Performance:**\n`;
        aiText += `• Revenue per ton: ${(precedentKPIs.revenuePerTon/1000).toFixed(0)}k → ${(baseKPIs.revenuePerTon/1000).toFixed(0)}k (${revenuePerTonChange > 0 ? '+' : ''}${(revenuePerTonChange/1000).toFixed(0)}k)\n`;
        aiText += `• Gross profit per ton: ${(precedentKPIs.grossProfitPerTon/1000).toFixed(0)}k → ${(baseKPIs.grossProfitPerTon/1000).toFixed(0)}k (${gpPerTonChange > 0 ? '+' : ''}${(gpPerTonChange/1000).toFixed(0)}k)\n`;
        aiText += `• Unit margin efficiency: ${((baseKPIs.grossProfitPerTon/baseKPIs.revenuePerTon) > (precedentKPIs.grossProfitPerTon/precedentKPIs.revenuePerTon)) ? 'IMPROVED' : 'DECLINED'} (${(baseKPIs.grossProfitPerTon/baseKPIs.revenuePerTon*100).toFixed(1)}% vs ${(precedentKPIs.grossProfitPerTon/precedentKPIs.revenuePerTon*100).toFixed(1)}%)\n\n`;
        
        // Period Comparison Summary
        aiText += `**Period Comparison Summary:**\n`;
        aiText += `• Overall performance vs previous period: ${salesChange > 2 && nmChange > 0.5 ? 'EXCELLENT - Strong revenue growth with margin expansion' : 
                                                            salesChange > 0 && nmChange > 0 ? 'STRONG - Revenue growth with profitability improvement' :
                                                            salesChange > 0 || nmChange > 0 ? 'POSITIVE - Either revenue or margin improvement achieved' :
                                                            salesChange > -3 && nmChange > -1 ? 'STABLE - Minor changes within acceptable range' :
                                                            'CONCERNING - Declining performance requires strategic intervention'}\n`;
        aiText += `• Key success factors: ${volumeChange > 2 ? 'Volume expansion, ' : ''}${priceChange > 0.05 ? 'Pricing power, ' : ''}${materialRatioChange < -0.3 ? 'Cost optimization, ' : ''}${mfgRatioChange < -0.3 ? 'Manufacturing efficiency' : ''}\n`;
        aiText += `• Areas of concern: ${volumeChange < -2 ? 'Volume decline, ' : ''}${priceChange < -0.05 ? 'Pricing pressure, ' : ''}${materialRatioChange > 0.5 ? 'Material cost inflation, ' : ''}${mfgRatioChange > 0.5 ? 'Manufacturing inefficiency' : 'None identified'}\n\n`;
      }
      
      // 2. BASE vs NEXT PERIOD ANALYSIS
      if (subsequentKPIs) {
        aiText += `**II. PERFORMANCE vs SUBSEQUENT PERIOD:**\n`;
        aiText += `**${basePeriodName} compared to ${subsequentKPIs.periodName}**\n\n`;
        
        const futureSalesChange = calculateVariance(subsequentKPIs, baseKPIs, 'sales');
        const futureVolumeChange = calculateVariance(subsequentKPIs, baseKPIs, 'salesVolume');
        const futureMarginChange = subsequentKPIs.netMargin - baseKPIs.netMargin;
        const futureGrossMarginChange = subsequentKPIs.grossMargin - baseKPIs.grossMargin;
        const futurePriceChange = subsequentKPIs.pricePerKg - baseKPIs.pricePerKg;
        
        aiText += `**Forward Performance Indicators:**\n`;
        aiText += `• Revenue Trajectory: ${(baseKPIs.sales/1000000).toFixed(1)}M → ${(subsequentKPIs.sales/1000000).toFixed(1)}M\n`;
        aiText += `  - Change: ${futureSalesChange !== null ? (futureSalesChange > 0 ? '+' : '') + futureSalesChange.toFixed(1) + '%' : 'N/A'}\n`;
        aiText += `  - Momentum: ${futureSalesChange > 3 ? 'ACCELERATING growth trajectory' : futureSalesChange > 0 ? 'Continued growth momentum' : futureSalesChange > -3 ? 'Slowing growth' : 'Revenue decline trend'}\n\n`;
        
        aiText += `• Volume Momentum: ${(baseKPIs.salesVolume/1000).toFixed(1)}k → ${(subsequentKPIs.salesVolume/1000).toFixed(1)}k tons\n`;
        aiText += `  - Change: ${futureVolumeChange !== null ? (futureVolumeChange > 0 ? '+' : '') + futureVolumeChange.toFixed(1) + '%' : 'N/A'}\n`;
        aiText += `  - Market dynamics: ${futureVolumeChange > 3 ? 'Strong market expansion or share gains' : futureVolumeChange > 0 ? 'Stable market demand' : futureVolumeChange > -3 ? 'Market softening' : 'Market contraction or share loss'}\n\n`;
        
        aiText += `• Pricing Evolution: ${baseKPIs.pricePerKg.toFixed(3)} → ${subsequentKPIs.pricePerKg.toFixed(3)}/kg\n`;
        aiText += `  - Change: ${futurePriceChange > 0 ? '+' : ''}${futurePriceChange.toFixed(3)}/kg (${(futurePriceChange/baseKPIs.pricePerKg*100).toFixed(1)}%)\n`;
        aiText += `  - Pricing trend: ${futurePriceChange > 0.05 ? 'Continued pricing strength' : futurePriceChange > 0 ? 'Stable pricing environment' : futurePriceChange > -0.05 ? 'Slight pricing pressure' : 'Significant pricing challenges'}\n\n`;
        
        aiText += `**Profitability Trajectory:**\n`;
        aiText += `• Gross Margin Trend: ${baseKPIs.grossMargin.toFixed(1)}% → ${subsequentKPIs.grossMargin.toFixed(1)}% (${futureGrossMarginChange > 0 ? '+' : ''}${futureGrossMarginChange.toFixed(1)} pp)\n`;
        aiText += `• Net Margin Trend: ${baseKPIs.netMargin.toFixed(1)}% → ${subsequentKPIs.netMargin.toFixed(1)}% (${futureMarginChange > 0 ? '+' : ''}${futureMarginChange.toFixed(1)} pp)\n`;
        aiText += `• Profitability outlook: ${futureMarginChange > 1 ? 'IMPROVING - Margin expansion continuing' : futureMarginChange > 0 ? 'STABLE IMPROVEMENT - Gradual margin gains' : futureMarginChange > -1 ? 'STABLE - Margins holding steady' : 'DECLINING - Margin compression trend'}\n\n`;
        
        aiText += `**Strategic Momentum Assessment:**\n`;
        aiText += `• Business trajectory: ${futureSalesChange > 3 && futureMarginChange > 0.5 ? 'EXCEPTIONAL - Accelerating growth with expanding margins demonstrates strong competitive position' : 
                                             futureSalesChange > 0 && futureMarginChange > 0 ? 'STRONG - Revenue growth with margin improvement shows healthy business momentum' :
                                             futureSalesChange > 0 || futureMarginChange > 0 ? 'MIXED - Some positive indicators but requires monitoring' :
                                             'CHALLENGING - Multiple headwinds requiring strategic response'}\n`;
        aiText += `• Market position: ${futurePriceChange > 0 && futureVolumeChange > 0 ? 'STRENGTHENING - Both volume and pricing power improving' : 
                                        futurePriceChange > 0 ? 'PREMIUM positioning maintained' : 
                                        futureVolumeChange > 0 ? 'VOLUME-focused strategy' : 
                                        'DEFENSIVE position required'}\n\n`;
      }
      
      // COMPREHENSIVE HISTORICAL CONTEXT
      if (historicalKPIs.length > 0) {
        aiText += `**COMPREHENSIVE HISTORICAL PERFORMANCE ANALYSIS:**\n\n`;
        
        // Multi-year averages and benchmarking
        const historicalAvgs = {
          sales: historicalKPIs.reduce((sum, k) => sum + k.sales, 0) / historicalKPIs.length / 1000000,
          netMargin: historicalKPIs.reduce((sum, k) => sum + k.netMargin, 0) / historicalKPIs.length,
          grossMargin: historicalKPIs.reduce((sum, k) => sum + k.grossMargin, 0) / historicalKPIs.length,
          ebitdaMargin: historicalKPIs.reduce((sum, k) => sum + k.ebitdaMargin, 0) / historicalKPIs.length,
          materialRatio: historicalKPIs.reduce((sum, k) => sum + k.materialRatio, 0) / historicalKPIs.length,
          mfgRatio: historicalKPIs.reduce((sum, k) => sum + k.mfgRatio, 0) / historicalKPIs.length,
          pricePerKg: historicalKPIs.reduce((sum, k) => sum + k.pricePerKg, 0) / historicalKPIs.length,
          revenuePerTon: historicalKPIs.reduce((sum, k) => sum + k.revenuePerTon, 0) / historicalKPIs.length
        };
        
        // Calculate historical volatility
        const salesStdDev = Math.sqrt(historicalKPIs.reduce((sum, k) => sum + Math.pow((k.sales/1000000) - historicalAvgs.sales, 2), 0) / historicalKPIs.length);
        const marginStdDev = Math.sqrt(historicalKPIs.reduce((sum, k) => sum + Math.pow(k.netMargin - historicalAvgs.netMargin, 2), 0) / historicalKPIs.length);
        
        aiText += `**Historical Benchmarking Analysis (${historicalKPIs.length} historical periods):**\n\n`;
        
        aiText += `**Sales Performance vs History:**\n`;
        aiText += `• Current sales: ${(baseKPIs.sales/1000000).toFixed(1)}M vs historical average: ${historicalAvgs.sales.toFixed(1)}M\n`;
        aiText += `• Performance vs average: ${((baseKPIs.sales/1000000 - historicalAvgs.sales) / historicalAvgs.sales * 100) > 0 ? '+' : ''}${((baseKPIs.sales/1000000 - historicalAvgs.sales) / historicalAvgs.sales * 100).toFixed(1)}% ${Math.abs((baseKPIs.sales/1000000 - historicalAvgs.sales) / historicalAvgs.sales * 100) > 10 ? '(SIGNIFICANT VARIANCE)' : '(MODERATE VARIANCE)'}\n`;
        aiText += `• Historical volatility: ${(salesStdDev/historicalAvgs.sales*100).toFixed(1)}% coefficient of variation ${salesStdDev/historicalAvgs.sales > 0.15 ? '(HIGH VOLATILITY)' : salesStdDev/historicalAvgs.sales > 0.08 ? '(MODERATE VOLATILITY)' : '(LOW VOLATILITY)'}\n`;
        aiText += `• Current position: ${Math.abs((baseKPIs.sales/1000000 - historicalAvgs.sales)/salesStdDev) < 1 ? 'Within normal range' : Math.abs((baseKPIs.sales/1000000 - historicalAvgs.sales)/salesStdDev) < 2 ? 'Moderately outside normal range' : 'Significantly outside historical norms'}\n\n`;
        
        aiText += `**Profitability vs Historical Norms:**\n`;
        aiText += `• Net Margin Analysis:\n`;
        aiText += `  - Current: ${baseKPIs.netMargin.toFixed(1)}% vs Historical avg: ${historicalAvgs.netMargin.toFixed(1)}% (${(baseKPIs.netMargin - historicalAvgs.netMargin) > 0 ? '+' : ''}${(baseKPIs.netMargin - historicalAvgs.netMargin).toFixed(1)} pp)\n`;
        aiText += `  - Performance rating: ${baseKPIs.netMargin > historicalAvgs.netMargin + marginStdDev ? 'EXCELLENT (Above 1 std dev)' : baseKPIs.netMargin > historicalAvgs.netMargin ? 'ABOVE AVERAGE' : baseKPIs.netMargin > historicalAvgs.netMargin - marginStdDev ? 'BELOW AVERAGE' : 'POOR (Below 1 std dev)'}\n`;
        aiText += `• Gross Margin Analysis:\n`;
        aiText += `  - Current: ${baseKPIs.grossMargin.toFixed(1)}% vs Historical avg: ${historicalAvgs.grossMargin.toFixed(1)}% (${(baseKPIs.grossMargin - historicalAvgs.grossMargin) > 0 ? '+' : ''}${(baseKPIs.grossMargin - historicalAvgs.grossMargin).toFixed(1)} pp)\n`;
        aiText += `• EBITDA Margin Analysis:\n`;
        aiText += `  - Current: ${baseKPIs.ebitdaMargin.toFixed(1)}% vs Historical avg: ${historicalAvgs.ebitdaMargin.toFixed(1)}% (${(baseKPIs.ebitdaMargin - historicalAvgs.ebitdaMargin) > 0 ? '+' : ''}${(baseKPIs.ebitdaMargin - historicalAvgs.ebitdaMargin).toFixed(1)} pp)\n\n`;
        
        aiText += `**Cost Structure vs Historical Benchmarks:**\n`;
        aiText += `• Material Cost Efficiency:\n`;
        aiText += `  - Current ratio: ${baseKPIs.materialRatio.toFixed(1)}% vs Historical avg: ${historicalAvgs.materialRatio.toFixed(1)}% (${(baseKPIs.materialRatio - historicalAvgs.materialRatio) > 0 ? '+' : ''}${(baseKPIs.materialRatio - historicalAvgs.materialRatio).toFixed(1)} pp)\n`;
        aiText += `  - Cost control assessment: ${baseKPIs.materialRatio < historicalAvgs.materialRatio - 1 ? 'EXCELLENT cost control' : baseKPIs.materialRatio < historicalAvgs.materialRatio ? 'Good cost management' : baseKPIs.materialRatio > historicalAvgs.materialRatio + 1 ? 'Cost control challenges' : 'Average cost performance'}\n`;
        aiText += `• Manufacturing Efficiency:\n`;
        aiText += `  - Current ratio: ${baseKPIs.mfgRatio.toFixed(1)}% vs Historical avg: ${historicalAvgs.mfgRatio.toFixed(1)}% (${(baseKPIs.mfgRatio - historicalAvgs.mfgRatio) > 0 ? '+' : ''}${(baseKPIs.mfgRatio - historicalAvgs.mfgRatio).toFixed(1)} pp)\n`;
        aiText += `• Pricing Strategy vs History:\n`;
        aiText += `  - Current price/kg: ${baseKPIs.pricePerKg.toFixed(3)} vs Historical avg: ${historicalAvgs.pricePerKg.toFixed(3)} (${(baseKPIs.pricePerKg - historicalAvgs.pricePerKg) > 0 ? '+' : ''}${(baseKPIs.pricePerKg - historicalAvgs.pricePerKg).toFixed(3)})\n`;
        aiText += `  - Revenue/ton: ${(baseKPIs.revenuePerTon/1000).toFixed(0)}k vs Historical avg: ${(historicalAvgs.revenuePerTon/1000).toFixed(0)}k (${((baseKPIs.revenuePerTon - historicalAvgs.revenuePerTon)/historicalAvgs.revenuePerTon*100) > 0 ? '+' : ''}${((baseKPIs.revenuePerTon - historicalAvgs.revenuePerTon)/historicalAvgs.revenuePerTon*100).toFixed(1)}%)\n\n`;
        
        // Performance ranking and percentile analysis
        const salesRanking = historicalKPIs.filter(k => k.sales > baseKPIs.sales).length + 1;
        const marginRanking = historicalKPIs.filter(k => k.netMargin > baseKPIs.netMargin).length + 1;
        const grossMarginRanking = historicalKPIs.filter(k => k.grossMargin > baseKPIs.grossMargin).length + 1;
        const totalPeriods = historicalKPIs.length + 1;
        
        aiText += `**Historical Performance Ranking & Percentile Analysis:**\n`;
        aiText += `• Sales Performance Ranking: ${salesRanking} of ${totalPeriods} periods (${(100 - (salesRanking-1)/totalPeriods*100).toFixed(0)}th percentile)\n`;
        aiText += `  - Classification: ${salesRanking <= totalPeriods/4 ? 'TOP QUARTILE - Elite performance' : salesRanking <= totalPeriods/2 ? 'UPPER HALF - Above median' : salesRanking <= 3*totalPeriods/4 ? 'LOWER HALF - Below median' : 'BOTTOM QUARTILE - Underperformance'}\n`;
        aiText += `• Profitability Ranking: ${marginRanking} of ${totalPeriods} periods (${(100 - (marginRanking-1)/totalPeriods*100).toFixed(0)}th percentile)\n`;
        aiText += `  - Classification: ${marginRanking <= totalPeriods/4 ? 'EXCEPTIONAL profitability' : marginRanking <= totalPeriods/2 ? 'ABOVE AVERAGE profitability' : marginRanking <= 3*totalPeriods/4 ? 'BELOW AVERAGE profitability' : 'POOR profitability performance'}\n`;
        aiText += `• Gross Margin Ranking: ${grossMarginRanking} of ${totalPeriods} periods (${(100 - (grossMarginRanking-1)/totalPeriods*100).toFixed(0)}th percentile)\n\n`;
        
        // Long-term trend analysis
        if (historicalKPIs.length >= 3) {
          const oldestPeriod = historicalKPIs[0];
          const yearsSpan = basePeriod.year - historicalKPIs[0].year || 1;
          const longTermSalesCAGR = Math.pow(baseKPIs.sales / oldestPeriod.sales, 1/yearsSpan) - 1;
          const longTermMarginTrend = baseKPIs.netMargin - oldestPeriod.netMargin;
          const longTermGrossMarginTrend = baseKPIs.grossMargin - oldestPeriod.grossMargin;
          const longTermMaterialRatioTrend = baseKPIs.materialRatio - oldestPeriod.materialRatio;
          
          aiText += `**Long-term Performance Trajectory (${oldestPeriod.periodName} to ${baseKPIs.periodName}):**\n`;
          aiText += `• Sales Growth Analysis:\n`;
          aiText += `  - Compound Annual Growth Rate (CAGR): ${(longTermSalesCAGR * 100).toFixed(1)}% over ${yearsSpan} years\n`;
          aiText += `  - Total growth: ${((baseKPIs.sales - oldestPeriod.sales)/oldestPeriod.sales*100).toFixed(1)}% (${(oldestPeriod.sales/1000000).toFixed(1)}M → ${(baseKPIs.sales/1000000).toFixed(1)}M)\n`;
          aiText += `  - Growth assessment: ${longTermSalesCAGR > 0.1 ? 'STRONG double-digit growth' : longTermSalesCAGR > 0.05 ? 'SOLID mid-single digit growth' : longTermSalesCAGR > 0 ? 'MODEST growth trajectory' : 'DECLINING sales trend'}\n`;
          
          aiText += `• Profitability Evolution:\n`;
          aiText += `  - Net margin progression: ${oldestPeriod.netMargin.toFixed(1)}% → ${baseKPIs.netMargin.toFixed(1)}% (${longTermMarginTrend > 0 ? '+' : ''}${longTermMarginTrend.toFixed(1)} pp over ${yearsSpan} years)\n`;
          aiText += `  - Gross margin progression: ${oldestPeriod.grossMargin.toFixed(1)}% → ${baseKPIs.grossMargin.toFixed(1)}% (${longTermGrossMarginTrend > 0 ? '+' : ''}${longTermGrossMarginTrend.toFixed(1)} pp)\n`;
          aiText += `• Margin trend assessment: ${longTermMarginTrend > 2 ? 'SIGNIFICANT margin expansion' : longTermMarginTrend > 0 ? 'Margin improvement' : longTermMarginTrend > -2 ? 'Stable margins' : 'Concerning margin erosion'}\n`;
          
          aiText += `• Cost Structure Evolution:\n`;
          aiText += `  - Material ratio trend: ${oldestPeriod.materialRatio.toFixed(1)}% → ${baseKPIs.materialRatio.toFixed(1)}% (${longTermMaterialRatioTrend > 0 ? '+' : ''}${longTermMaterialRatioTrend.toFixed(1)} pp)\n`;
          aiText += `  - Cost efficiency trend: ${longTermMaterialRatioTrend < -1 ? 'Excellent cost optimization' : longTermMaterialRatioTrend < 0 ? 'Good cost control' : longTermMaterialRatioTrend < 1 ? 'Stable cost structure' : 'Cost inflation challenges'}\n`;
          
          aiText += `• Overall Long-term Assessment:\n`;
          aiText += `  - Strategic performance: ${longTermSalesCAGR > 0.05 && longTermMarginTrend > 1 ? 'EXCEPTIONAL - Strong growth with margin expansion demonstrates superior business execution and market positioning' :
                                                  longTermSalesCAGR > 0.03 && longTermMarginTrend > 0 ? 'STRONG - Solid growth with profitability improvement shows good strategic execution' :
                                                  longTermSalesCAGR > 0 && longTermMarginTrend > -1 ? 'SATISFACTORY - Positive growth with stable margins indicates decent performance' :
                                                  longTermSalesCAGR > -0.02 ? 'CONCERNING - Stagnant growth requires strategic intervention' :
                                                  'CRITICAL - Declining performance demands immediate comprehensive strategy overhaul'}\n\n`;
        }
      }

      // Multi-Period Trend Analysis - NEW SECTION
      const allActualPeriods = selectedPeriods.filter(p => p.type === 'Actual' && p !== basePeriod);
      const allBudgetPeriods = selectedPeriods.filter(p => p.type === 'Budget');
      
      // Calculate trend metrics across multiple periods
      let trendAnalysis = {
        salesTrend: [],
        marginTrend: [],
        volumeTrend: [],
        periodCount: 0
      };
      
      if (allActualPeriods.length > 0) {
        const sortedPeriods = [...allActualPeriods, basePeriod].sort((a, b) => {
          if (a.year !== b.year) return a.year - b.year;
          if (a.month && b.month) return a.month - b.month;
          return 0;
        });
        
        for (let i = 0; i < sortedPeriods.length; i++) {
          const period = sortedPeriods[i];
          const periodSales = getKPI(ROWS.sales, period);
          const periodNetProfit = getKPI(ROWS.netProfit, period);
          const periodVolume = getKPI(ROWS.salesVolume, period);
          
          if (periodSales > 0) {
            trendAnalysis.salesTrend.push({
              period: `${period.year} ${period.month || ''} ${period.type}`.trim(),
              sales: periodSales / 1000000,
              margin: (periodNetProfit / periodSales) * 100,
              volume: periodVolume / 1000,
              isBase: period === basePeriod
            });
            trendAnalysis.periodCount++;
          }
        }
      }

      console.log(`Writeup generation #${generationCount + 1} completed successfully`);
      setWriteup(aiText);
      setHasAutoGenerated(true);
      setGenerationCount(generationCount + 1);
      
    } catch (err) {
      console.error('Error generating writeup:', err);
      setError(`Failed to generate analysis: ${err.message}`);
    } finally {
      // Always reset loading state
      console.log('Resetting loading state to false');
      setLoading(false);
      clearTimeout(timeoutId);
    }
  }

  // No automatic generation - user must click Generate
  useEffect(() => {
    // Clear writeup when period changes, but don't auto-generate
    setWriteup('');
    setHasAutoGenerated(false);
    setGenerationCount(0); // Reset generation count for new period
    setError(null);
    // eslint-disable-next-line
  }, [periodKey, division]);

  // Split writeup into summary and bullet points
  const [summary, ...bullets] = writeup.split(/\n• /);
  const bulletPoints = bullets.map((b, i) => (b.trim().startsWith('•') ? b.trim().slice(1) : b.trim()));

  // Handle contentEditable changes
  const handleDivEdit = (e) => {
    setWriteup(e.currentTarget.innerText);
    setEditing(true);
  };
  const handleDivBlur = async (e) => {
    setEditing(false);
    // No auto-save - user can manually save if needed
  };

  // Update the display formatting function
  const formatWriteupForDisplay = (text) => {
    if (!text) return null;
    const paragraphs = text.split('\n\n').filter(p => p.trim() !== '');
    return paragraphs.map((para, pIdx) => {
      if (para.includes('\n• ')) {
        const [heading, ...items] = para.split('\n• ');
        return (
          <div key={pIdx}>
            <div dangerouslySetInnerHTML={{ __html: heading.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') }} />
            <ul style={{ margin: 0, paddingLeft: 24 }}>
              {items.map((item, iIdx) => (
                <li key={`${pIdx}-${iIdx}`} style={{ marginBottom: 8 }} dangerouslySetInnerHTML={{ __html: item.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') }} />
              ))}
            </ul>
          </div>
        );
      } else {
        return <div key={pIdx} style={{ marginBottom: 12 }} dangerouslySetInnerHTML={{ __html: para.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') }} />;
      }
    });
  };

  return (
    <div style={{
      marginTop: 40,
      background: '#fff',
      borderRadius: 8,
      boxShadow: '0 2px 10px rgba(0,0,0,0.05)',
      padding: 24,
      width: 1024, // Wider panel
      marginLeft: 'auto',
      marginRight: 'auto',
      textAlign: 'left',
    }}>
      <h2 style={{ fontSize: 24, fontWeight: 700, marginBottom: 8, fontFamily: 'Segoe UI, Roboto, Arial, sans-serif' }}>Write-up</h2>
      <div style={{ fontSize: 18, fontWeight: 500, color: '#288cfa', marginBottom: 16, fontFamily: 'Segoe UI, Roboto, Arial, sans-serif' }}>
        {divisionNames[division] || division}
      </div>
      {error && <div style={{ color: 'red', marginBottom: 8 }}>{error}</div>}
      <div
        contentEditable
        suppressContentEditableWarning
        onInput={handleDivEdit}
        onBlur={handleDivBlur}
        style={{
          width: '100%',
          fontSize: 18,
          fontFamily: 'Segoe UI, Roboto, Arial, sans-serif',
          borderRadius: 6,
          border: '1px solid #ccc',
          padding: 16,
          minHeight: 120,
          background: '#fafbfc',
          outline: 'none',
          lineHeight: 1.7,
          marginBottom: 12,
          whiteSpace: 'pre-wrap',
          boxSizing: 'border-box',
          textAlign: 'left',
        }}
        spellCheck={true}
      >
        {writeup ? (
          <>
            {formatWriteupForDisplay(writeup)}
          </>
        ) : (
          <div style={{ color: '#666', fontStyle: 'italic' }}>
            Click "Generate" to create AI-powered performance analysis with year-over-year comparisons, budget variance analysis, and strategic recommendations.
          </div>
        )}
      </div>
      <div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: 12 }}>
        <button
          onClick={generateAIWriteup}
          disabled={loading}
          style={{
            background: '#288cfa',
            color: '#fff',
            border: 'none',
            borderRadius: 4,
            padding: '8px 20px',
            fontWeight: 600,
            fontSize: 16,
            cursor: loading ? 'not-allowed' : 'pointer',
            opacity: loading ? 0.7 : 1
          }}
        >
          {loading ? 'Generating...' : (writeup ? 'Regenerate' : 'Generate')}
        </button>
      </div>
    </div>
  );
};

export default AIWriteupPanel; 